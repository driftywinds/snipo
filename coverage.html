
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>server: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/MohamedElashri/snipo/cmd/server/main.go (0.0%)</option>
				
				<option value="file1">github.com/MohamedElashri/snipo/internal/api/handlers/auth.go (0.0%)</option>
				
				<option value="file2">github.com/MohamedElashri/snipo/internal/api/handlers/backup.go (0.0%)</option>
				
				<option value="file3">github.com/MohamedElashri/snipo/internal/api/handlers/folders.go (17.1%)</option>
				
				<option value="file4">github.com/MohamedElashri/snipo/internal/api/handlers/health.go (81.2%)</option>
				
				<option value="file5">github.com/MohamedElashri/snipo/internal/api/handlers/response.go (68.8%)</option>
				
				<option value="file6">github.com/MohamedElashri/snipo/internal/api/handlers/snippets.go (45.1%)</option>
				
				<option value="file7">github.com/MohamedElashri/snipo/internal/api/handlers/tags.go (20.9%)</option>
				
				<option value="file8">github.com/MohamedElashri/snipo/internal/api/handlers/tokens.go (0.0%)</option>
				
				<option value="file9">github.com/MohamedElashri/snipo/internal/api/middleware/middleware.go (0.0%)</option>
				
				<option value="file10">github.com/MohamedElashri/snipo/internal/api/router.go (0.0%)</option>
				
				<option value="file11">github.com/MohamedElashri/snipo/internal/auth/auth.go (0.0%)</option>
				
				<option value="file12">github.com/MohamedElashri/snipo/internal/config/config.go (0.0%)</option>
				
				<option value="file13">github.com/MohamedElashri/snipo/internal/database/database.go (0.0%)</option>
				
				<option value="file14">github.com/MohamedElashri/snipo/internal/database/migrations.go (0.0%)</option>
				
				<option value="file15">github.com/MohamedElashri/snipo/internal/models/snippet.go (0.0%)</option>
				
				<option value="file16">github.com/MohamedElashri/snipo/internal/repository/folder_repo.go (81.1%)</option>
				
				<option value="file17">github.com/MohamedElashri/snipo/internal/repository/snippet_file_repo.go (0.0%)</option>
				
				<option value="file18">github.com/MohamedElashri/snipo/internal/repository/snippet_repo.go (74.6%)</option>
				
				<option value="file19">github.com/MohamedElashri/snipo/internal/repository/tag_repo.go (81.7%)</option>
				
				<option value="file20">github.com/MohamedElashri/snipo/internal/repository/token_repo.go (0.0%)</option>
				
				<option value="file21">github.com/MohamedElashri/snipo/internal/services/backup_service.go (0.0%)</option>
				
				<option value="file22">github.com/MohamedElashri/snipo/internal/services/s3_sync_service.go (0.0%)</option>
				
				<option value="file23">github.com/MohamedElashri/snipo/internal/services/snippet_service.go (0.0%)</option>
				
				<option value="file24">github.com/MohamedElashri/snipo/internal/storage/s3.go (0.0%)</option>
				
				<option value="file25">github.com/MohamedElashri/snipo/internal/testutil/testutil.go (0.0%)</option>
				
				<option value="file26">github.com/MohamedElashri/snipo/internal/validation/validation.go (94.0%)</option>
				
				<option value="file27">github.com/MohamedElashri/snipo/internal/web/handler.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "log/slog"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"

        "github.com/MohamedElashri/snipo/internal/api"
        "github.com/MohamedElashri/snipo/internal/auth"
        "github.com/MohamedElashri/snipo/internal/config"
        "github.com/MohamedElashri/snipo/internal/database"
)

// Build-time variables
var (
        Version = "dev"
        Commit  = "unknown"
)

func main() <span class="cov0" title="0">{
        // Check for subcommands
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                switch os.Args[1] </span>{
                case "serve":<span class="cov0" title="0">
                        runServer()</span>
                case "migrate":<span class="cov0" title="0">
                        runMigrations()</span>
                case "version":<span class="cov0" title="0">
                        fmt.Printf("snipo %s (commit: %s)\n", Version, Commit)
                        os.Exit(0)</span>
                case "health":<span class="cov0" title="0">
                        checkHealth()</span>
                default:<span class="cov0" title="0">
                        fmt.Printf("Unknown command: %s\n", os.Args[1])
                        fmt.Println("Available commands: serve, migrate, version, health")
                        os.Exit(1)</span>
                }
        } else<span class="cov0" title="0"> {
                runServer()
        }</span>
}

func runServer() <span class="cov0" title="0">{
        // Setup logger
        logger := setupLogger()

        logger.Info("starting snipo", "version", Version, "commit", Commit)

        // Load configuration
        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to load configuration", "error", err)
                os.Exit(1)
        }</span>

        // Connect to database
        <span class="cov0" title="0">db, err := database.New(database.Config{
                Path:            cfg.Database.Path,
                MaxOpenConns:    cfg.Database.MaxOpenConns,
                BusyTimeout:     cfg.Database.BusyTimeout,
                JournalMode:     cfg.Database.JournalMode,
                SynchronousMode: cfg.Database.SynchronousMode,
        }, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to connect to database", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        // Run migrations
        ctx := context.Background()
        if err := db.Migrate(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to run migrations", "error", err)
                os.Exit(1)
        }</span>

        // Create auth service
        <span class="cov0" title="0">authService := auth.NewService(
                db.DB,
                cfg.Auth.MasterPassword,
                cfg.Auth.SessionSecret,
                cfg.Auth.SessionDuration,
                logger,
        )

        // Start session cleanup goroutine
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(1 * time.Hour)
                for range ticker.C </span><span class="cov0" title="0">{
                        if err := authService.CleanupExpiredSessions(); err != nil </span><span class="cov0" title="0">{
                                logger.Warn("failed to cleanup sessions", "error", err)
                        }</span>
                }
        }()

        // Create router
        <span class="cov0" title="0">router := api.NewRouter(api.RouterConfig{
                DB:                 db.DB,
                Logger:             logger,
                AuthService:        authService,
                Version:            Version,
                Commit:             Commit,
                RateLimit:          cfg.Auth.RateLimit,
                RateLimitWindow:    int(cfg.Auth.RateLimitWindow.Seconds()),
                MaxFilesPerSnippet: cfg.Server.MaxFilesPerSnippet,
                S3Config:           &amp;cfg.S3,
        })

        // Create server
        server := &amp;http.Server{
                Addr:         cfg.Server.Addr(),
                Handler:      router,
                ReadTimeout:  cfg.Server.ReadTimeout,
                WriteTimeout: cfg.Server.WriteTimeout,
                IdleTimeout:  120 * time.Second,
        }

        // Start server in goroutine
        go func() </span><span class="cov0" title="0">{
                logger.Info("server listening", "addr", cfg.Server.Addr())
                if err := server.ListenAndServe(); err != nil &amp;&amp; err != http.ErrServerClosed </span><span class="cov0" title="0">{
                        logger.Error("server error", "error", err)
                        os.Exit(1)
                }</span>
        }()

        // Wait for interrupt signal
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit

        logger.Info("shutting down server...")

        // Graceful shutdown with timeout
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("server forced to shutdown", "error", err)
        }</span>

        <span class="cov0" title="0">logger.Info("server stopped")</span>
}

func runMigrations() <span class="cov0" title="0">{
        logger := setupLogger()

        cfg, err := config.Load()
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to load configuration", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">db, err := database.New(database.Config{
                Path:            cfg.Database.Path,
                MaxOpenConns:    cfg.Database.MaxOpenConns,
                BusyTimeout:     cfg.Database.BusyTimeout,
                JournalMode:     cfg.Database.JournalMode,
                SynchronousMode: cfg.Database.SynchronousMode,
        }, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to connect to database", "error", err)
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer db.Close()

        ctx := context.Background()
        if err := db.Migrate(ctx); err != nil </span><span class="cov0" title="0">{
                logger.Error("failed to run migrations", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">logger.Info("migrations completed successfully")</span>
}

func checkHealth() <span class="cov0" title="0">{
        // Simple health check for Docker HEALTHCHECK
        resp, err := http.Get("http://localhost:8080/ping")
        if err != nil </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                os.Exit(1)
        }</span>
        <span class="cov0" title="0">os.Exit(0)</span>
}

func setupLogger() *slog.Logger <span class="cov0" title="0">{
        logLevel := os.Getenv("SNIPO_LOG_LEVEL")
        logFormat := os.Getenv("SNIPO_LOG_FORMAT")

        var level slog.Level
        switch logLevel </span>{
        case "debug":<span class="cov0" title="0">
                level = slog.LevelDebug</span>
        case "warn":<span class="cov0" title="0">
                level = slog.LevelWarn</span>
        case "error":<span class="cov0" title="0">
                level = slog.LevelError</span>
        default:<span class="cov0" title="0">
                level = slog.LevelInfo</span>
        }

        <span class="cov0" title="0">opts := &amp;slog.HandlerOptions{Level: level}

        var handler slog.Handler
        if logFormat == "text" </span><span class="cov0" title="0">{
                handler = slog.NewTextHandler(os.Stdout, opts)
        }</span> else<span class="cov0" title="0"> {
                handler = slog.NewJSONHandler(os.Stdout, opts)
        }</span>

        <span class="cov0" title="0">return slog.New(handler)</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"

        "github.com/MohamedElashri/snipo/internal/auth"
)

// AuthHandler handles authentication-related HTTP requests
type AuthHandler struct {
        authService *auth.Service
}

// NewAuthHandler creates a new auth handler
func NewAuthHandler(authService *auth.Service) *AuthHandler <span class="cov0" title="0">{
        return &amp;AuthHandler{authService: authService}
}</span>

// LoginRequest represents a login request
type LoginRequest struct {
        Password string `json:"password"`
}

// LoginResponse represents a login response
type LoginResponse struct {
        Success bool   `json:"success"`
        Message string `json:"message,omitempty"`
}

// Login handles POST /api/v1/auth/login
func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req LoginRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        <span class="cov0" title="0">if req.Password == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_PASSWORD", "Password is required")
                return
        }</span>

        <span class="cov0" title="0">if !h.authService.VerifyPassword(req.Password) </span><span class="cov0" title="0">{
                Error(w, http.StatusUnauthorized, "INVALID_CREDENTIALS", "Invalid password")
                return
        }</span>

        // Create session
        <span class="cov0" title="0">token, err := h.authService.CreateSession()
        if err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        // Set session cookie
        <span class="cov0" title="0">h.authService.SetSessionCookie(w, token)

        OK(w, LoginResponse{
                Success: true,
                Message: "Login successful",
        })</span>
}

// Logout handles POST /api/v1/auth/logout
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        token := auth.GetSessionFromRequest(r)
        if token != "" </span><span class="cov0" title="0">{
                h.authService.InvalidateSession(token)
        }</span>

        <span class="cov0" title="0">h.authService.ClearSessionCookie(w)

        OK(w, LoginResponse{
                Success: true,
                Message: "Logout successful",
        })</span>
}

// Check handles GET /api/v1/auth/check
func (h *AuthHandler) Check(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        token := auth.GetSessionFromRequest(r)
        if token == "" || !h.authService.ValidateSession(token) </span><span class="cov0" title="0">{
                Unauthorized(w)
                return
        }</span>

        <span class="cov0" title="0">OK(w, map[string]bool{"authenticated": true})</span>
}

// ChangePasswordRequest represents a password change request
type ChangePasswordRequest struct {
        CurrentPassword string `json:"current_password"`
        NewPassword     string `json:"new_password"`
}

// ChangePassword handles POST /api/v1/auth/change-password
func (h *AuthHandler) ChangePassword(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var req ChangePasswordRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        <span class="cov0" title="0">if req.CurrentPassword == "" || req.NewPassword == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_FIELDS", "Current and new password are required")
                return
        }</span>

        <span class="cov0" title="0">if len(req.NewPassword) &lt; 6 </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "PASSWORD_TOO_SHORT", "Password must be at least 6 characters")
                return
        }</span>

        // Verify current password
        <span class="cov0" title="0">if !h.authService.VerifyPassword(req.CurrentPassword) </span><span class="cov0" title="0">{
                Error(w, http.StatusUnauthorized, "INVALID_PASSWORD", "Current password is incorrect")
                return
        }</span>

        // Update password
        <span class="cov0" title="0">if err := h.authService.UpdatePassword(req.NewPassword); err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        <span class="cov0" title="0">OK(w, map[string]interface{}{
                "success": true,
                "message": "Password changed successfully",
        })</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package handlers

import (
        "encoding/json"
        "io"
        "net/http"

        "github.com/MohamedElashri/snipo/internal/models"
        "github.com/MohamedElashri/snipo/internal/services"
)

// BackupHandler handles backup-related HTTP requests
type BackupHandler struct {
        backupSvc *services.BackupService
        s3SyncSvc *services.S3SyncService // May be nil if S3 is not configured
}

// NewBackupHandler creates a new backup handler
func NewBackupHandler(backupSvc *services.BackupService, s3SyncSvc *services.S3SyncService) *BackupHandler <span class="cov0" title="0">{
        return &amp;BackupHandler{
                backupSvc: backupSvc,
                s3SyncSvc: s3SyncSvc,
        }
}</span>

// Export handles GET /api/v1/backup/export
// Query params: format (json|zip), password (optional)
func (h *BackupHandler) Export(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        opts := models.ExportOptions{
                Format:   r.URL.Query().Get("format"),
                Password: r.URL.Query().Get("password"),
        }

        if opts.Format == "" </span><span class="cov0" title="0">{
                opts.Format = "json"
        }</span>

        <span class="cov0" title="0">content, filename, err := h.backupSvc.Export(r.Context(), opts)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusInternalServerError, "BACKUP_FAILED", err.Error())
                return
        }</span>

        // Determine content type
        <span class="cov0" title="0">contentType := "application/json"
        if opts.Format == "zip" </span><span class="cov0" title="0">{
                contentType = "application/zip"
        }</span>
        <span class="cov0" title="0">if opts.Password != "" </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", contentType)
        w.Header().Set("Content-Disposition", "attachment; filename=\""+filename+"\"")
        w.WriteHeader(http.StatusOK)
        w.Write(content)</span>
}

// Import handles POST /api/v1/backup/import
// Form data: file (multipart), strategy (replace|merge|skip), password (optional)
func (h *BackupHandler) Import(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Parse multipart form (max 50MB)
        if err := r.ParseMultipartForm(50 &lt;&lt; 20); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_REQUEST", "Failed to parse form data")
                return
        }</span>

        <span class="cov0" title="0">file, _, err := r.FormFile("file")
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_FILE", "No backup file provided")
                return
        }</span>
        <span class="cov0" title="0">defer file.Close()

        content, err := io.ReadAll(file)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "READ_ERROR", "Failed to read backup file")
                return
        }</span>

        <span class="cov0" title="0">opts := models.ImportOptions{
                Strategy: r.FormValue("strategy"),
                Password: r.FormValue("password"),
        }

        if opts.Strategy == "" </span><span class="cov0" title="0">{
                opts.Strategy = "merge"
        }</span>

        <span class="cov0" title="0">result, err := h.backupSvc.Import(r.Context(), content, opts)
        if err != nil </span><span class="cov0" title="0">{
                if err == services.ErrDecryptionFailed </span><span class="cov0" title="0">{
                        Error(w, http.StatusBadRequest, "DECRYPTION_FAILED", "Failed to decrypt backup - wrong password?")
                        return
                }</span>
                <span class="cov0" title="0">if err == services.ErrInvalidBackupFormat </span><span class="cov0" title="0">{
                        Error(w, http.StatusBadRequest, "INVALID_FORMAT", "Invalid backup file format")
                        return
                }</span>
                <span class="cov0" title="0">Error(w, http.StatusInternalServerError, "IMPORT_FAILED", err.Error())
                return</span>
        }

        <span class="cov0" title="0">OK(w, result)</span>
}

// S3Sync handles POST /api/v1/backup/s3/sync
// Body: { "format": "json|zip", "password": "optional" }
func (h *BackupHandler) S3Sync(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if h.s3SyncSvc == nil </span><span class="cov0" title="0">{
                Error(w, http.StatusServiceUnavailable, "S3_NOT_CONFIGURED", "S3 storage is not configured")
                return
        }</span>

        <span class="cov0" title="0">var opts models.ExportOptions
        if err := json.NewDecoder(r.Body).Decode(&amp;opts); err != nil </span><span class="cov0" title="0">{
                // Use defaults if no body
                opts.Format = "json"
        }</span>

        <span class="cov0" title="0">result, err := h.s3SyncSvc.SyncToS3(r.Context(), opts)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusInternalServerError, "SYNC_FAILED", err.Error())
                return
        }</span>

        <span class="cov0" title="0">OK(w, result)</span>
}

// S3List handles GET /api/v1/backup/s3/list
func (h *BackupHandler) S3List(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if h.s3SyncSvc == nil </span><span class="cov0" title="0">{
                Error(w, http.StatusServiceUnavailable, "S3_NOT_CONFIGURED", "S3 storage is not configured")
                return
        }</span>

        <span class="cov0" title="0">backups, err := h.s3SyncSvc.ListBackups(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusInternalServerError, "LIST_FAILED", err.Error())
                return
        }</span>

        <span class="cov0" title="0">OK(w, map[string]interface{}{
                "backups": backups,
        })</span>
}

// S3Restore handles POST /api/v1/backup/s3/restore
// Body: { "key": "backups/snipo-backup-xxx.json", "strategy": "replace|merge|skip", "password": "optional" }
func (h *BackupHandler) S3Restore(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if h.s3SyncSvc == nil </span><span class="cov0" title="0">{
                Error(w, http.StatusServiceUnavailable, "S3_NOT_CONFIGURED", "S3 storage is not configured")
                return
        }</span>

        <span class="cov0" title="0">var req struct {
                Key      string `json:"key"`
                Strategy string `json:"strategy"`
                Password string `json:"password"`
        }

        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_REQUEST", "Invalid request body")
                return
        }</span>

        <span class="cov0" title="0">if req.Key == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_KEY", "Backup key is required")
                return
        }</span>

        <span class="cov0" title="0">opts := models.ImportOptions{
                Strategy: req.Strategy,
                Password: req.Password,
        }

        if opts.Strategy == "" </span><span class="cov0" title="0">{
                opts.Strategy = "merge"
        }</span>

        <span class="cov0" title="0">result, err := h.s3SyncSvc.RestoreFromS3(r.Context(), req.Key, opts)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusInternalServerError, "RESTORE_FAILED", err.Error())
                return
        }</span>

        <span class="cov0" title="0">OK(w, result)</span>
}

// S3Delete handles DELETE /api/v1/backup/s3/{key}
func (h *BackupHandler) S3Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        if h.s3SyncSvc == nil </span><span class="cov0" title="0">{
                Error(w, http.StatusServiceUnavailable, "S3_NOT_CONFIGURED", "S3 storage is not configured")
                return
        }</span>

        <span class="cov0" title="0">key := r.URL.Query().Get("key")
        if key == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_KEY", "Backup key is required")
                return
        }</span>

        <span class="cov0" title="0">if err := h.s3SyncSvc.DeleteBackup(r.Context(), key); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusInternalServerError, "DELETE_FAILED", err.Error())
                return
        }</span>

        <span class="cov0" title="0">OK(w, map[string]string{
                "message": "Backup deleted successfully",
        })</span>
}

// S3Status handles GET /api/v1/backup/s3/status
func (h *BackupHandler) S3Status(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        status := map[string]interface{}{
                "enabled": h.s3SyncSvc != nil,
        }

        OK(w, status)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/go-chi/chi/v5"

        "github.com/MohamedElashri/snipo/internal/models"
        "github.com/MohamedElashri/snipo/internal/repository"
)

// FolderHandler handles folder-related HTTP requests
type FolderHandler struct {
        repo *repository.FolderRepository
}

// NewFolderHandler creates a new folder handler
func NewFolderHandler(repo *repository.FolderRepository) *FolderHandler <span class="cov10" title="3">{
        return &amp;FolderHandler{repo: repo}
}</span>

// List handles GET /api/v1/folders
func (h *FolderHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov6" title="2">{
        // Check if tree format is requested
        tree := r.URL.Query().Get("tree") == "true"

        var folders []models.Folder
        var err error

        if tree </span><span class="cov1" title="1">{
                folders, err = h.repo.ListTree(r.Context())
        }</span> else<span class="cov1" title="1"> {
                folders, err = h.repo.List(r.Context())
        }</span>

        <span class="cov6" title="2">if err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        // Get snippet counts for each folder (only for flat list)
        <span class="cov6" title="2">if !tree </span><span class="cov1" title="1">{
                for i := range folders </span><span class="cov10" title="3">{
                        count, err := h.repo.GetFolderSnippetCount(r.Context(), folders[i].ID)
                        if err == nil </span><span class="cov10" title="3">{
                                folders[i].SnippetCount = count
                        }</span>
                }
        }

        <span class="cov6" title="2">OK(w, map[string]interface{}{"data": folders})</span>
}

// Create handles POST /api/v1/folders
func (h *FolderHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        var input models.FolderInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        // Validate input
        <span class="cov1" title="1">if input.Name == "" </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name is required"}})
                return
        }</span>

        <span class="cov1" title="1">if len(input.Name) &gt; 100 </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name must be 100 characters or less"}})
                return
        }</span>

        // Validate parent exists if provided
        <span class="cov1" title="1">if input.ParentID != nil </span><span class="cov0" title="0">{
                _, err := h.repo.GetByID(r.Context(), *input.ParentID)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                                ValidationErrors(w, []ValidationError{{Field: "parent_id", Message: "Parent folder not found"}})
                                return
                        }</span>
                        <span class="cov0" title="0">InternalError(w)
                        return</span>
                }
        }

        <span class="cov1" title="1">folder, err := h.repo.Create(r.Context(), &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        <span class="cov1" title="1">Created(w, folder)</span>
}

// Get handles GET /api/v1/folders/{id}
func (h *FolderHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_ID", "Invalid folder ID")
                return
        }</span>

        <span class="cov0" title="0">folder, err := h.repo.GetByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Folder not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        // Get snippet count
        <span class="cov0" title="0">count, err := h.repo.GetFolderSnippetCount(r.Context(), folder.ID)
        if err == nil </span><span class="cov0" title="0">{
                folder.SnippetCount = count
        }</span>

        <span class="cov0" title="0">OK(w, folder)</span>
}

// Update handles PUT /api/v1/folders/{id}
func (h *FolderHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_ID", "Invalid folder ID")
                return
        }</span>

        <span class="cov0" title="0">var input models.FolderInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if input.Name == "" </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name is required"}})
                return
        }</span>

        <span class="cov0" title="0">if len(input.Name) &gt; 100 </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name must be 100 characters or less"}})
                return
        }</span>

        // Validate parent exists if provided and not self-referencing
        <span class="cov0" title="0">if input.ParentID != nil </span><span class="cov0" title="0">{
                if *input.ParentID == id </span><span class="cov0" title="0">{
                        ValidationErrors(w, []ValidationError{{Field: "parent_id", Message: "Folder cannot be its own parent"}})
                        return
                }</span>

                <span class="cov0" title="0">_, err := h.repo.GetByID(r.Context(), *input.ParentID)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                                ValidationErrors(w, []ValidationError{{Field: "parent_id", Message: "Parent folder not found"}})
                                return
                        }</span>
                        <span class="cov0" title="0">InternalError(w)
                        return</span>
                }
        }

        <span class="cov0" title="0">folder, err := h.repo.Update(r.Context(), id, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Folder not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov0" title="0">OK(w, folder)</span>
}

// Delete handles DELETE /api/v1/folders/{id}
func (h *FolderHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_ID", "Invalid folder ID")
                return
        }</span>

        <span class="cov0" title="0">err = h.repo.Delete(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Folder not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov0" title="0">NoContent(w)</span>
}

// MoveRequest represents a request to move a folder
type MoveRequest struct {
        ParentID *int64 `json:"parent_id"`
}

// Move handles PUT /api/v1/folders/{id}/move
func (h *FolderHandler) Move(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_ID", "Invalid folder ID")
                return
        }</span>

        <span class="cov0" title="0">var req MoveRequest
        if err := json.NewDecoder(r.Body).Decode(&amp;req); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        // Validate not moving to self
        <span class="cov0" title="0">if req.ParentID != nil &amp;&amp; *req.ParentID == id </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "parent_id", Message: "Folder cannot be its own parent"}})
                return
        }</span>

        // Validate parent exists if provided
        <span class="cov0" title="0">if req.ParentID != nil </span><span class="cov0" title="0">{
                _, err := h.repo.GetByID(r.Context(), *req.ParentID)
                if err != nil </span><span class="cov0" title="0">{
                        if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                                ValidationErrors(w, []ValidationError{{Field: "parent_id", Message: "Parent folder not found"}})
                                return
                        }</span>
                        <span class="cov0" title="0">InternalError(w)
                        return</span>
                }
        }

        <span class="cov0" title="0">folder, err := h.repo.Move(r.Context(), id, req.ParentID)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Folder not found")
                        return
                }</span>
                // Check for circular reference error
                <span class="cov0" title="0">if err.Error() == "cannot move folder: would create circular reference" </span><span class="cov0" title="0">{
                        ValidationErrors(w, []ValidationError{{Field: "parent_id", Message: "Cannot move folder: would create circular reference"}})
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov0" title="0">OK(w, folder)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package handlers

import (
        "database/sql"
        "net/http"
        "runtime"
        "time"
)

// HealthHandler handles health check requests
type HealthHandler struct {
        db        *sql.DB
        startTime time.Time
        version   string
        commit    string
}

// NewHealthHandler creates a new health handler
func NewHealthHandler(db *sql.DB, version, commit string) *HealthHandler <span class="cov10" title="2">{
        return &amp;HealthHandler{
                db:        db,
                startTime: time.Now(),
                version:   version,
                commit:    commit,
        }
}</span>

// HealthResponse represents the health check response
type HealthResponse struct {
        Status    string            `json:"status"`
        Version   string            `json:"version"`
        Commit    string            `json:"commit,omitempty"`
        Uptime    string            `json:"uptime"`
        Checks    map[string]string `json:"checks"`
        Memory    MemoryStats       `json:"memory"`
        Timestamp string            `json:"timestamp"`
}

// MemoryStats represents memory statistics
type MemoryStats struct {
        Alloc      uint64 `json:"alloc_mb"`
        TotalAlloc uint64 `json:"total_alloc_mb"`
        Sys        uint64 `json:"sys_mb"`
        NumGC      uint32 `json:"num_gc"`
}

// Health handles GET /health
func (h *HealthHandler) Health(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        checks := make(map[string]string)
        status := "healthy"

        // Check database
        if err := h.db.Ping(); err != nil </span><span class="cov0" title="0">{
                checks["database"] = "unhealthy: " + err.Error()
                status = "unhealthy"
        }</span> else<span class="cov1" title="1"> {
                checks["database"] = "healthy"
        }</span>

        // Get memory stats
        <span class="cov1" title="1">var m runtime.MemStats
        runtime.ReadMemStats(&amp;m)

        response := HealthResponse{
                Status:  status,
                Version: h.version,
                Commit:  h.commit,
                Uptime:  time.Since(h.startTime).Round(time.Second).String(),
                Checks:  checks,
                Memory: MemoryStats{
                        Alloc:      m.Alloc / 1024 / 1024,
                        TotalAlloc: m.TotalAlloc / 1024 / 1024,
                        Sys:        m.Sys / 1024 / 1024,
                        NumGC:      m.NumGC,
                },
                Timestamp: time.Now().UTC().Format(time.RFC3339),
        }

        if status == "healthy" </span><span class="cov1" title="1">{
                OK(w, response)
        }</span> else<span class="cov0" title="0"> {
                JSON(w, http.StatusServiceUnavailable, response)
        }</span>
}

// Ping handles GET /ping - simple liveness check
func (h *HealthHandler) Ping(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        w.Header().Set("Content-Type", "text/plain")
        w.WriteHeader(http.StatusOK)
        w.Write([]byte("pong"))
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package handlers

import (
        "encoding/json"
        "net/http"
)

// ErrorResponse represents an API error response
type ErrorResponse struct {
        Error ErrorDetail `json:"error"`
}

// ErrorDetail contains error details
type ErrorDetail struct {
        Code    string            `json:"code"`
        Message string            `json:"message"`
        Details []ValidationError `json:"details,omitempty"`
}

// ValidationError represents a field validation error
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// JSON sends a JSON response
func JSON(w http.ResponseWriter, status int, data interface{}) <span class="cov10" title="16">{
        w.Header().Set("Content-Type", "application/json")
        w.WriteHeader(status)

        if data != nil </span><span class="cov10" title="16">{
                if err := json.NewEncoder(w).Encode(data); err != nil </span><span class="cov0" title="0">{
                        // Log error but can't do much at this point
                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                }</span>
        }
}

// Error sends an error response
func Error(w http.ResponseWriter, status int, code, message string) <span class="cov3" title="2">{
        JSON(w, status, ErrorResponse{
                Error: ErrorDetail{
                        Code:    code,
                        Message: message,
                },
        })
}</span>

// ValidationErrors sends a validation error response
func ValidationErrors(w http.ResponseWriter, errors []ValidationError) <span class="cov1" title="1">{
        JSON(w, http.StatusBadRequest, ErrorResponse{
                Error: ErrorDetail{
                        Code:    "VALIDATION_ERROR",
                        Message: "Invalid request payload",
                        Details: errors,
                },
        })
}</span>

// NotFound sends a 404 response
func NotFound(w http.ResponseWriter, message string) <span class="cov1" title="1">{
        if message == "" </span><span class="cov0" title="0">{
                message = "Resource not found"
        }</span>
        <span class="cov1" title="1">Error(w, http.StatusNotFound, "NOT_FOUND", message)</span>
}

// Unauthorized sends a 401 response
func Unauthorized(w http.ResponseWriter) <span class="cov0" title="0">{
        Error(w, http.StatusUnauthorized, "UNAUTHORIZED", "Authentication required")
}</span>

// Forbidden sends a 403 response
func Forbidden(w http.ResponseWriter) <span class="cov0" title="0">{
        Error(w, http.StatusForbidden, "FORBIDDEN", "Access denied")
}</span>

// InternalError sends a 500 response
func InternalError(w http.ResponseWriter) <span class="cov0" title="0">{
        Error(w, http.StatusInternalServerError, "INTERNAL_ERROR", "An internal error occurred")
}</span>

// Created sends a 201 response with the created resource
func Created(w http.ResponseWriter, data interface{}) <span class="cov4" title="3">{
        JSON(w, http.StatusCreated, data)
}</span>

// NoContent sends a 204 response
func NoContent(w http.ResponseWriter) <span class="cov1" title="1">{
        w.WriteHeader(http.StatusNoContent)
}</span>

// OK sends a 200 response
func OK(w http.ResponseWriter, data interface{}) <span class="cov8" title="10">{
        JSON(w, http.StatusOK, data)
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/go-chi/chi/v5"

        "github.com/MohamedElashri/snipo/internal/models"
        "github.com/MohamedElashri/snipo/internal/services"
        "github.com/MohamedElashri/snipo/internal/validation"
)

// SnippetHandler handles snippet-related HTTP requests
type SnippetHandler struct {
        service *services.SnippetService
}

// NewSnippetHandler creates a new snippet handler
func NewSnippetHandler(service *services.SnippetService) *SnippetHandler <span class="cov10" title="11">{
        return &amp;SnippetHandler{service: service}
}</span>

// List handles GET /api/v1/snippets
func (h *SnippetHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov3" title="2">{
        filter := models.DefaultSnippetFilter()

        // Parse query parameters
        if page := r.URL.Query().Get("page"); page != "" </span><span class="cov1" title="1">{
                if p, err := strconv.Atoi(page); err == nil &amp;&amp; p &gt; 0 </span><span class="cov1" title="1">{
                        filter.Page = p
                }</span>
        }

        <span class="cov3" title="2">if limit := r.URL.Query().Get("limit"); limit != "" </span><span class="cov1" title="1">{
                if l, err := strconv.Atoi(limit); err == nil &amp;&amp; l &gt; 0 </span><span class="cov1" title="1">{
                        filter.Limit = l
                }</span>
        }

        <span class="cov3" title="2">if q := r.URL.Query().Get("q"); q != "" </span><span class="cov0" title="0">{
                filter.Query = q
        }</span>

        <span class="cov3" title="2">if lang := r.URL.Query().Get("language"); lang != "" </span><span class="cov0" title="0">{
                filter.Language = lang
        }</span>

        <span class="cov3" title="2">if fav := r.URL.Query().Get("favorite"); fav != "" </span><span class="cov0" title="0">{
                isFav := fav == "true" || fav == "1"
                filter.IsFavorite = &amp;isFav
        }</span>

        <span class="cov3" title="2">if tagID := r.URL.Query().Get("tag_id"); tagID != "" </span><span class="cov0" title="0">{
                if id, err := strconv.ParseInt(tagID, 10, 64); err == nil &amp;&amp; id &gt; 0 </span><span class="cov0" title="0">{
                        filter.TagID = id
                }</span>
        }

        <span class="cov3" title="2">if folderID := r.URL.Query().Get("folder_id"); folderID != "" </span><span class="cov0" title="0">{
                if id, err := strconv.ParseInt(folderID, 10, 64); err == nil &amp;&amp; id &gt; 0 </span><span class="cov0" title="0">{
                        filter.FolderID = id
                }</span>
        }

        <span class="cov3" title="2">if sortBy := r.URL.Query().Get("sort"); sortBy != "" </span><span class="cov0" title="0">{
                filter.SortBy = sortBy
        }</span>

        <span class="cov3" title="2">if order := r.URL.Query().Get("order"); order != "" </span><span class="cov0" title="0">{
                filter.SortOrder = order
        }</span>

        <span class="cov3" title="2">result, err := h.service.List(r.Context(), filter)
        if err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        <span class="cov3" title="2">OK(w, result)</span>
}

// Create handles POST /api/v1/snippets
func (h *SnippetHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov5" title="3">{
        var input models.SnippetInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov1" title="1">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        <span class="cov3" title="2">snippet, err := h.service.Create(r.Context(), &amp;input)
        if err != nil </span><span class="cov1" title="1">{
                // Check if it's a validation error
                var validationErrs validation.ValidationErrors
                if errors.As(err, &amp;validationErrs) </span><span class="cov1" title="1">{
                        errs := make([]ValidationError, len(validationErrs))
                        for i, e := range validationErrs </span><span class="cov1" title="1">{
                                errs[i] = ValidationError{Field: e.Field, Message: e.Message}
                        }</span>
                        <span class="cov1" title="1">ValidationErrors(w, errs)
                        return</span>
                }
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov1" title="1">Created(w, snippet)</span>
}

// Get handles GET /api/v1/snippets/{id}
func (h *SnippetHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov3" title="2">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_ID", "Snippet ID is required")
                return
        }</span>

        <span class="cov3" title="2">snippet, err := h.service.GetByID(r.Context(), id)
        if err != nil </span><span class="cov1" title="1">{
                if errors.Is(err, services.ErrSnippetNotFound) </span><span class="cov1" title="1">{
                        NotFound(w, "Snippet not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov1" title="1">OK(w, snippet)</span>
}

// Update handles PUT /api/v1/snippets/{id}
func (h *SnippetHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_ID", "Snippet ID is required")
                return
        }</span>

        <span class="cov1" title="1">var input models.SnippetInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        <span class="cov1" title="1">snippet, err := h.service.Update(r.Context(), id, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, services.ErrSnippetNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Snippet not found")
                        return
                }</span>
                <span class="cov0" title="0">var validationErrs validation.ValidationErrors
                if errors.As(err, &amp;validationErrs) </span><span class="cov0" title="0">{
                        errs := make([]ValidationError, len(validationErrs))
                        for i, e := range validationErrs </span><span class="cov0" title="0">{
                                errs[i] = ValidationError{Field: e.Field, Message: e.Message}
                        }</span>
                        <span class="cov0" title="0">ValidationErrors(w, errs)
                        return</span>
                }
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov1" title="1">OK(w, snippet)</span>
}

// Delete handles DELETE /api/v1/snippets/{id}
func (h *SnippetHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_ID", "Snippet ID is required")
                return
        }</span>

        <span class="cov1" title="1">err := h.service.Delete(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, services.ErrSnippetNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Snippet not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov1" title="1">NoContent(w)</span>
}

// ToggleFavorite handles POST /api/v1/snippets/{id}/favorite
func (h *SnippetHandler) ToggleFavorite(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_ID", "Snippet ID is required")
                return
        }</span>

        <span class="cov1" title="1">snippet, err := h.service.ToggleFavorite(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, services.ErrSnippetNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Snippet not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov1" title="1">OK(w, snippet)</span>
}

// Duplicate handles POST /api/v1/snippets/{id}/duplicate
func (h *SnippetHandler) Duplicate(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_ID", "Snippet ID is required")
                return
        }</span>

        <span class="cov0" title="0">snippet, err := h.service.Duplicate(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, services.ErrSnippetNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Snippet not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov0" title="0">Created(w, snippet)</span>
}

// Search handles GET /api/v1/snippets/search
func (h *SnippetHandler) Search(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        query := r.URL.Query().Get("q")
        if query == "" </span><span class="cov0" title="0">{
                OK(w, map[string]interface{}{"data": []models.Snippet{}})
                return
        }</span>

        <span class="cov1" title="1">limit := 10
        if l := r.URL.Query().Get("limit"); l != "" </span><span class="cov0" title="0">{
                if parsed, err := strconv.Atoi(l); err == nil &amp;&amp; parsed &gt; 0 </span><span class="cov0" title="0">{
                        limit = parsed
                }</span>
        }

        <span class="cov1" title="1">snippets, err := h.service.Search(r.Context(), query, limit)
        if err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        <span class="cov1" title="1">OK(w, map[string]interface{}{"data": snippets})</span>
}

// GetPublic handles GET /api/v1/snippets/public/{id}
func (h *SnippetHandler) GetPublic(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id := chi.URLParam(r, "id")
        if id == "" </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "MISSING_ID", "Snippet ID is required")
                return
        }</span>

        <span class="cov0" title="0">snippet, err := h.service.GetByIDPublic(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, services.ErrSnippetNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Snippet not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov0" title="0">OK(w, snippet)</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/go-chi/chi/v5"

        "github.com/MohamedElashri/snipo/internal/models"
        "github.com/MohamedElashri/snipo/internal/repository"
)

// TagHandler handles tag-related HTTP requests
type TagHandler struct {
        repo *repository.TagRepository
}

// NewTagHandler creates a new tag handler
func NewTagHandler(repo *repository.TagRepository) *TagHandler <span class="cov6" title="2">{
        return &amp;TagHandler{repo: repo}
}</span>

// List handles GET /api/v1/tags
func (h *TagHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        tags, err := h.repo.List(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        // Get snippet counts for each tag
        <span class="cov1" title="1">for i := range tags </span><span class="cov10" title="3">{
                count, err := h.repo.GetTagSnippetCount(r.Context(), tags[i].ID)
                if err == nil </span><span class="cov10" title="3">{
                        tags[i].SnippetCount = count
                }</span>
        }

        <span class="cov1" title="1">OK(w, map[string]interface{}{"data": tags})</span>
}

// Create handles POST /api/v1/tags
func (h *TagHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov1" title="1">{
        var input models.TagInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        // Validate input
        <span class="cov1" title="1">if input.Name == "" </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name is required"}})
                return
        }</span>

        <span class="cov1" title="1">if len(input.Name) &gt; 50 </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name must be 50 characters or less"}})
                return
        }</span>

        // Set default color if not provided
        <span class="cov1" title="1">if input.Color == "" </span><span class="cov0" title="0">{
                input.Color = "#6366f1"
        }</span>

        // Check if tag already exists
        <span class="cov1" title="1">existing, err := h.repo.GetByName(r.Context(), input.Name)
        if err == nil &amp;&amp; existing != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusConflict, "TAG_EXISTS", "A tag with this name already exists")
                return
        }</span>

        <span class="cov1" title="1">tag, err := h.repo.Create(r.Context(), &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        <span class="cov1" title="1">Created(w, tag)</span>
}

// Get handles GET /api/v1/tags/{id}
func (h *TagHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_ID", "Invalid tag ID")
                return
        }</span>

        <span class="cov0" title="0">tag, err := h.repo.GetByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Tag not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        // Get snippet count
        <span class="cov0" title="0">count, err := h.repo.GetTagSnippetCount(r.Context(), tag.ID)
        if err == nil </span><span class="cov0" title="0">{
                tag.SnippetCount = count
        }</span>

        <span class="cov0" title="0">OK(w, tag)</span>
}

// Update handles PUT /api/v1/tags/{id}
func (h *TagHandler) Update(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_ID", "Invalid tag ID")
                return
        }</span>

        <span class="cov0" title="0">var input models.TagInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if input.Name == "" </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name is required"}})
                return
        }</span>

        <span class="cov0" title="0">if len(input.Name) &gt; 50 </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name must be 50 characters or less"}})
                return
        }</span>

        // Check if another tag with same name exists
        <span class="cov0" title="0">existing, err := h.repo.GetByName(r.Context(), input.Name)
        if err == nil &amp;&amp; existing != nil &amp;&amp; existing.ID != id </span><span class="cov0" title="0">{
                Error(w, http.StatusConflict, "TAG_EXISTS", "A tag with this name already exists")
                return
        }</span>

        // Set default color if not provided
        <span class="cov0" title="0">if input.Color == "" </span><span class="cov0" title="0">{
                input.Color = "#6366f1"
        }</span>

        <span class="cov0" title="0">tag, err := h.repo.Update(r.Context(), id, &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Tag not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov0" title="0">OK(w, tag)</span>
}

// Delete handles DELETE /api/v1/tags/{id}
func (h *TagHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_ID", "Invalid tag ID")
                return
        }</span>

        <span class="cov0" title="0">err = h.repo.Delete(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Tag not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov0" title="0">NoContent(w)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package handlers

import (
        "encoding/json"
        "errors"
        "net/http"
        "strconv"

        "github.com/go-chi/chi/v5"

        "github.com/MohamedElashri/snipo/internal/models"
        "github.com/MohamedElashri/snipo/internal/repository"
)

// TokenHandler handles API token-related HTTP requests
type TokenHandler struct {
        repo *repository.TokenRepository
}

// NewTokenHandler creates a new token handler
func NewTokenHandler(repo *repository.TokenRepository) *TokenHandler <span class="cov0" title="0">{
        return &amp;TokenHandler{repo: repo}
}</span>

// List handles GET /api/v1/tokens
func (h *TokenHandler) List(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        tokens, err := h.repo.List(r.Context())
        if err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        <span class="cov0" title="0">OK(w, map[string]interface{}{"data": tokens})</span>
}

// Create handles POST /api/v1/tokens
func (h *TokenHandler) Create(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        var input models.APITokenInput
        if err := json.NewDecoder(r.Body).Decode(&amp;input); err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_JSON", "Invalid JSON payload")
                return
        }</span>

        // Validate input
        <span class="cov0" title="0">if input.Name == "" </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name is required"}})
                return
        }</span>

        <span class="cov0" title="0">if len(input.Name) &gt; 100 </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "name", Message: "Name must be 100 characters or less"}})
                return
        }</span>

        // Validate permissions
        <span class="cov0" title="0">if input.Permissions != "" &amp;&amp; input.Permissions != "read" &amp;&amp; input.Permissions != "write" &amp;&amp; input.Permissions != "admin" </span><span class="cov0" title="0">{
                ValidationErrors(w, []ValidationError{{Field: "permissions", Message: "Permissions must be 'read', 'write', or 'admin'"}})
                return
        }</span>

        <span class="cov0" title="0">token, err := h.repo.Create(r.Context(), &amp;input)
        if err != nil </span><span class="cov0" title="0">{
                InternalError(w)
                return
        }</span>

        // Return the token with the plain text token (only time it's shown)
        <span class="cov0" title="0">Created(w, token)</span>
}

// Get handles GET /api/v1/tokens/{id}
func (h *TokenHandler) Get(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_ID", "Invalid token ID")
                return
        }</span>

        <span class="cov0" title="0">token, err := h.repo.GetByID(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Token not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov0" title="0">OK(w, token)</span>
}

// Delete handles DELETE /api/v1/tokens/{id}
func (h *TokenHandler) Delete(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        id, err := strconv.ParseInt(chi.URLParam(r, "id"), 10, 64)
        if err != nil </span><span class="cov0" title="0">{
                Error(w, http.StatusBadRequest, "INVALID_ID", "Invalid token ID")
                return
        }</span>

        <span class="cov0" title="0">err = h.repo.Delete(r.Context(), id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, repository.ErrNotFound) </span><span class="cov0" title="0">{
                        NotFound(w, "Token not found")
                        return
                }</span>
                <span class="cov0" title="0">InternalError(w)
                return</span>
        }

        <span class="cov0" title="0">NoContent(w)</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package middleware

import (
        "context"
        "log/slog"
        "net/http"
        "runtime/debug"
        "strings"
        "sync"
        "time"

        "github.com/MohamedElashri/snipo/internal/auth"
        "github.com/MohamedElashri/snipo/internal/repository"
)

// Context keys for authentication
type contextKey string

const (
        // ContextKeyAPIToken is the context key for API token
        ContextKeyAPIToken contextKey = "api_token"
)

// SecurityHeaders adds essential security headers to responses
func SecurityHeaders(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Prevent XSS
                w.Header().Set("X-Content-Type-Options", "nosniff")
                w.Header().Set("X-Frame-Options", "DENY")
                w.Header().Set("X-XSS-Protection", "1; mode=block")

                // Content Security Policy - all resources served locally
                w.Header().Set("Content-Security-Policy", strings.Join([]string{
                        "default-src 'self'",
                        "script-src 'self' 'unsafe-inline' 'unsafe-eval'", // unsafe-eval needed for Alpine.js
                        "style-src 'self' 'unsafe-inline'",
                        "img-src 'self' data: blob:",
                        "font-src 'self'",
                        "connect-src 'self'",
                        "frame-ancestors 'none'",
                        "form-action 'self'",
                        "base-uri 'self'",
                }, "; "))

                // HTTPS enforcement (only in production)
                w.Header().Set("Strict-Transport-Security", "max-age=31536000; includeSubDomains")

                // Referrer policy
                w.Header().Set("Referrer-Policy", "strict-origin-when-cross-origin")

                // Permissions policy
                w.Header().Set("Permissions-Policy", "camera=(), microphone=(), geolocation=()")

                next.ServeHTTP(w, r)
        }</span>)
}

// Logger logs HTTP requests
func Logger(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        start := time.Now()

                        // Wrap response writer to capture status code
                        wrapped := &amp;responseWriter{ResponseWriter: w, statusCode: http.StatusOK}

                        next.ServeHTTP(wrapped, r)

                        duration := time.Since(start)

                        logger.Info("request",
                                "method", r.Method,
                                "path", r.URL.Path,
                                "status", wrapped.statusCode,
                                "duration", duration,
                                "ip", getClientIP(r),
                        )
                }</span>)
        }
}

// responseWriter wraps http.ResponseWriter to capture status code
type responseWriter struct {
        http.ResponseWriter
        statusCode int
}

func (rw *responseWriter) WriteHeader(code int) <span class="cov0" title="0">{
        rw.statusCode = code
        rw.ResponseWriter.WriteHeader(code)
}</span>

// Recovery recovers from panics and logs the error
func Recovery(logger *slog.Logger) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                if err := recover(); err != nil </span><span class="cov0" title="0">{
                                        logger.Error("panic recovered",
                                                "error", err,
                                                "stack", string(debug.Stack()),
                                                "path", r.URL.Path,
                                        )
                                        http.Error(w, "Internal Server Error", http.StatusInternalServerError)
                                }</span>
                        }()
                        <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
                })
        }
}

// RequireAuth checks for valid authentication (session or API token)
func RequireAuth(authService *auth.Service) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return RequireAuthWithTokenRepo(authService, nil)
}</span>

// RequireAuthWithTokenRepo checks for valid authentication with API token support
func RequireAuthWithTokenRepo(authService *auth.Service, tokenRepo *repository.TokenRepository) func(http.Handler) http.Handler <span class="cov0" title="0">{
        return func(next http.Handler) http.Handler </span><span class="cov0" title="0">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                        // First, check for API token in header
                        if tokenRepo != nil </span><span class="cov0" title="0">{
                                // Check Authorization header (Bearer token)
                                authHeader := r.Header.Get("Authorization")
                                if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                                        token := strings.TrimPrefix(authHeader, "Bearer ")
                                        apiToken, err := tokenRepo.ValidateToken(r.Context(), token)
                                        if err == nil &amp;&amp; apiToken != nil </span><span class="cov0" title="0">{
                                                // Valid API token, add to context and continue
                                                ctx := context.WithValue(r.Context(), ContextKeyAPIToken, apiToken)
                                                next.ServeHTTP(w, r.WithContext(ctx))
                                                return
                                        }</span>
                                }

                                // Check X-API-Key header
                                <span class="cov0" title="0">apiKey := r.Header.Get("X-API-Key")
                                if apiKey != "" </span><span class="cov0" title="0">{
                                        apiToken, err := tokenRepo.ValidateToken(r.Context(), apiKey)
                                        if err == nil &amp;&amp; apiToken != nil </span><span class="cov0" title="0">{
                                                // Valid API token, add to context and continue
                                                ctx := context.WithValue(r.Context(), ContextKeyAPIToken, apiToken)
                                                next.ServeHTTP(w, r.WithContext(ctx))
                                                return
                                        }</span>
                                }
                        }

                        // Fall back to session authentication
                        <span class="cov0" title="0">sessionToken := auth.GetSessionFromRequest(r)
                        if sessionToken != "" &amp;&amp; authService.ValidateSession(sessionToken) </span><span class="cov0" title="0">{
                                next.ServeHTTP(w, r)
                                return
                        }</span>

                        // No valid authentication found
                        <span class="cov0" title="0">if strings.HasPrefix(r.URL.Path, "/api/") </span><span class="cov0" title="0">{
                                http.Error(w, "Unauthorized", http.StatusUnauthorized)
                        }</span> else<span class="cov0" title="0"> {
                                http.Redirect(w, r, "/login", http.StatusSeeOther)
                        }</span>
                })
        }
}

// RateLimiter implements a simple in-memory rate limiter
type RateLimiter struct {
        requests map[string][]time.Time
        mu       sync.RWMutex
        limit    int
        window   time.Duration
}

// NewRateLimiter creates a new rate limiter
func NewRateLimiter(limit int, window time.Duration) *RateLimiter <span class="cov0" title="0">{
        rl := &amp;RateLimiter{
                requests: make(map[string][]time.Time),
                limit:    limit,
                window:   window,
        }

        // Start cleanup goroutine
        go rl.cleanup()

        return rl
}</span>

// Middleware returns the rate limiting middleware
func (rl *RateLimiter) Middleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                ip := getClientIP(r)
                now := time.Now()

                rl.mu.Lock()

                // Clean old requests for this IP
                var recent []time.Time
                for _, t := range rl.requests[ip] </span><span class="cov0" title="0">{
                        if now.Sub(t) &lt; rl.window </span><span class="cov0" title="0">{
                                recent = append(recent, t)
                        }</span>
                }

                <span class="cov0" title="0">if len(recent) &gt;= rl.limit </span><span class="cov0" title="0">{
                        rl.mu.Unlock()
                        w.Header().Set("Retry-After", "60")
                        http.Error(w, "Too Many Requests", http.StatusTooManyRequests)
                        return
                }</span>

                <span class="cov0" title="0">rl.requests[ip] = append(recent, now)
                rl.mu.Unlock()

                next.ServeHTTP(w, r)</span>
        })
}

// cleanup periodically removes old entries
func (rl *RateLimiter) cleanup() <span class="cov0" title="0">{
        ticker := time.NewTicker(5 * time.Minute)
        for range ticker.C </span><span class="cov0" title="0">{
                rl.mu.Lock()
                now := time.Now()
                for ip, times := range rl.requests </span><span class="cov0" title="0">{
                        var recent []time.Time
                        for _, t := range times </span><span class="cov0" title="0">{
                                if now.Sub(t) &lt; rl.window </span><span class="cov0" title="0">{
                                        recent = append(recent, t)
                                }</span>
                        }
                        <span class="cov0" title="0">if len(recent) == 0 </span><span class="cov0" title="0">{
                                delete(rl.requests, ip)
                        }</span> else<span class="cov0" title="0"> {
                                rl.requests[ip] = recent
                        }</span>
                }
                <span class="cov0" title="0">rl.mu.Unlock()</span>
        }
}

// getClientIP extracts the client IP from the request
func getClientIP(r *http.Request) string <span class="cov0" title="0">{
        // Check X-Forwarded-For header
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                ips := strings.Split(xff, ",")
                if len(ips) &gt; 0 </span><span class="cov0" title="0">{
                        return strings.TrimSpace(ips[0])
                }</span>
        }

        // Check X-Real-IP header
        <span class="cov0" title="0">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                return xri
        }</span>

        // Fall back to RemoteAddr
        <span class="cov0" title="0">ip := r.RemoteAddr
        if idx := strings.LastIndex(ip, ":"); idx != -1 </span><span class="cov0" title="0">{
                ip = ip[:idx]
        }</span>
        <span class="cov0" title="0">return ip</span>
}

// CORS adds CORS headers for API requests
func CORS(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                w.Header().Set("Access-Control-Allow-Origin", "*")
                w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
                w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-API-Key")
                w.Header().Set("Access-Control-Max-Age", "86400")

                if r.Method == "OPTIONS" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusNoContent)
                        return
                }</span>

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package api

import (
        "database/sql"
        "log/slog"
        "net/http"

        "github.com/go-chi/chi/v5"

        "github.com/MohamedElashri/snipo/internal/api/handlers"
        "github.com/MohamedElashri/snipo/internal/api/middleware"
        "github.com/MohamedElashri/snipo/internal/auth"
        "github.com/MohamedElashri/snipo/internal/config"
        "github.com/MohamedElashri/snipo/internal/repository"
        "github.com/MohamedElashri/snipo/internal/services"
        "github.com/MohamedElashri/snipo/internal/storage"
        "github.com/MohamedElashri/snipo/internal/web"
)

// RouterConfig holds router configuration
type RouterConfig struct {
        DB                 *sql.DB
        Logger             *slog.Logger
        AuthService        *auth.Service
        Version            string
        Commit             string
        RateLimit          int
        RateLimitWindow    int // in seconds
        MaxFilesPerSnippet int
        S3Config           *config.S3Config
}

// NewRouter creates and configures the HTTP router
func NewRouter(cfg RouterConfig) http.Handler <span class="cov0" title="0">{
        r := chi.NewRouter()

        // Global middleware
        r.Use(middleware.Recovery(cfg.Logger))
        r.Use(middleware.Logger(cfg.Logger))
        r.Use(middleware.SecurityHeaders)
        r.Use(middleware.CORS)

        // Rate limiting for auth endpoints
        rateLimiter := middleware.NewRateLimiter(cfg.RateLimit, 60*1000*1000*1000) // 1 minute in nanoseconds (nothing planck scale)

        // Create repositories
        snippetRepo := repository.NewSnippetRepository(cfg.DB)
        tagRepo := repository.NewTagRepository(cfg.DB)
        folderRepo := repository.NewFolderRepository(cfg.DB)
        tokenRepo := repository.NewTokenRepository(cfg.DB)
        fileRepo := repository.NewSnippetFileRepository(cfg.DB)

        // Create services
        snippetService := services.NewSnippetService(snippetRepo, cfg.Logger).
                WithTagRepo(tagRepo).
                WithFolderRepo(folderRepo).
                WithFileRepo(fileRepo).
                WithMaxFiles(cfg.MaxFilesPerSnippet)

        // Create backup service
        backupService := services.NewBackupService(cfg.DB, snippetService, tagRepo, folderRepo, fileRepo, cfg.Logger)

        // Create S3 sync service if configured
        var s3SyncService *services.S3SyncService
        if cfg.S3Config != nil &amp;&amp; cfg.S3Config.Enabled </span><span class="cov0" title="0">{
                s3Storage, err := storage.NewS3Storage(storage.S3Config{
                        Endpoint:        cfg.S3Config.Endpoint,
                        AccessKeyID:     cfg.S3Config.AccessKeyID,
                        SecretAccessKey: cfg.S3Config.SecretAccessKey,
                        Bucket:          cfg.S3Config.Bucket,
                        Region:          cfg.S3Config.Region,
                        UseSSL:          cfg.S3Config.UseSSL,
                })
                if err != nil </span><span class="cov0" title="0">{
                        cfg.Logger.Warn("failed to initialize S3 storage", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        s3SyncService = services.NewS3SyncService(s3Storage, backupService, cfg.Logger)
                        cfg.Logger.Info("S3 storage initialized", "bucket", cfg.S3Config.Bucket)
                }</span>
        }

        // Create handlers
        <span class="cov0" title="0">snippetHandler := handlers.NewSnippetHandler(snippetService)
        tagHandler := handlers.NewTagHandler(tagRepo)
        folderHandler := handlers.NewFolderHandler(folderRepo)
        tokenHandler := handlers.NewTokenHandler(tokenRepo)
        authHandler := handlers.NewAuthHandler(cfg.AuthService)
        healthHandler := handlers.NewHealthHandler(cfg.DB, cfg.Version, cfg.Commit)
        backupHandler := handlers.NewBackupHandler(backupService, s3SyncService)

        // Public routes (no auth required)
        r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                // Health checks
                r.Get("/health", healthHandler.Health)
                r.Get("/ping", healthHandler.Ping)

                // Public snippet access
                r.Get("/api/v1/snippets/public/{id}", snippetHandler.GetPublic)

                // Auth endpoints (with rate limiting)
                r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Use(rateLimiter.Middleware)
                        r.Post("/api/v1/auth/login", authHandler.Login)
                }</span>)

                <span class="cov0" title="0">r.Post("/api/v1/auth/logout", authHandler.Logout)
                r.Get("/api/v1/auth/check", authHandler.Check)</span>
        })

        // Protected routes (auth required)
        <span class="cov0" title="0">r.Group(func(r chi.Router) </span><span class="cov0" title="0">{
                r.Use(middleware.RequireAuthWithTokenRepo(cfg.AuthService, tokenRepo))

                // Auth management (protected)
                r.Post("/api/v1/auth/change-password", authHandler.ChangePassword)

                // Snippet CRUD
                r.Route("/api/v1/snippets", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Get("/", snippetHandler.List)
                        r.Post("/", snippetHandler.Create)
                        r.Get("/search", snippetHandler.Search)

                        r.Route("/{id}", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", snippetHandler.Get)
                                r.Put("/", snippetHandler.Update)
                                r.Delete("/", snippetHandler.Delete)
                                r.Post("/favorite", snippetHandler.ToggleFavorite)
                                r.Post("/duplicate", snippetHandler.Duplicate)
                        }</span>)
                })

                // Tag CRUD
                <span class="cov0" title="0">r.Route("/api/v1/tags", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Get("/", tagHandler.List)
                        r.Post("/", tagHandler.Create)

                        r.Route("/{id}", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", tagHandler.Get)
                                r.Put("/", tagHandler.Update)
                                r.Delete("/", tagHandler.Delete)
                        }</span>)
                })

                // Folder CRUD
                <span class="cov0" title="0">r.Route("/api/v1/folders", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Get("/", folderHandler.List)
                        r.Post("/", folderHandler.Create)

                        r.Route("/{id}", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", folderHandler.Get)
                                r.Put("/", folderHandler.Update)
                                r.Delete("/", folderHandler.Delete)
                                r.Put("/move", folderHandler.Move)
                        }</span>)
                })

                // API Token management
                <span class="cov0" title="0">r.Route("/api/v1/tokens", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Get("/", tokenHandler.List)
                        r.Post("/", tokenHandler.Create)

                        r.Route("/{id}", func(r chi.Router) </span><span class="cov0" title="0">{
                                r.Get("/", tokenHandler.Get)
                                r.Delete("/", tokenHandler.Delete)
                        }</span>)
                })

                // Backup &amp; Restore
                <span class="cov0" title="0">r.Route("/api/v1/backup", func(r chi.Router) </span><span class="cov0" title="0">{
                        r.Get("/export", backupHandler.Export)
                        r.Post("/import", backupHandler.Import)

                        // S3 operations
                        r.Get("/s3/status", backupHandler.S3Status)
                        r.Post("/s3/sync", backupHandler.S3Sync)
                        r.Get("/s3/list", backupHandler.S3List)
                        r.Post("/s3/restore", backupHandler.S3Restore)
                        r.Delete("/s3/delete", backupHandler.S3Delete)
                }</span>)
        })

        // Web UI routes
        <span class="cov0" title="0">webHandler, err := web.NewHandler(cfg.AuthService)
        if err != nil </span><span class="cov0" title="0">{
                cfg.Logger.Error("failed to create web handler", "error", err)
        }</span> else<span class="cov0" title="0"> {
                // Static files
                r.Handle("/static/*", web.StaticHandler())

                // Web pages
                r.Get("/", webHandler.Index)
                r.Get("/login", webHandler.Login)
                r.Get("/s/{id}", webHandler.PublicSnippet) // Public snippet share page
        }</span>

        <span class="cov0" title="0">return r</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package auth

import (
        "crypto/rand"
        "crypto/sha256"
        "crypto/subtle"
        "database/sql"
        "encoding/base64"
        "encoding/hex"
        "errors"
        "fmt"
        "log/slog"
        "net/http"
        "strings"
        "time"

        "golang.org/x/crypto/argon2"
)

// Common errors
var (
        ErrInvalidCredentials = errors.New("invalid credentials")
        ErrSessionExpired     = errors.New("session expired")
        ErrInvalidToken       = errors.New("invalid token")
)

// Argon2id parameters (OWASP recommended)
const (
        argonTime    = 1
        argonMemory  = 64 * 1024
        argonThreads = 4
        argonKeyLen  = 32
)

// Config holds authentication configuration
type Config struct {
        MasterPasswordHash string
        SessionSecret      string
        SessionDuration    time.Duration
}

// Service handles authentication
type Service struct {
        db              *sql.DB
        masterPassword  string
        sessionSecret   string
        sessionDuration time.Duration
        logger          *slog.Logger
}

// NewService creates a new authentication service
func NewService(db *sql.DB, masterPassword, sessionSecret string, sessionDuration time.Duration, logger *slog.Logger) *Service <span class="cov0" title="0">{
        return &amp;Service{
                db:              db,
                masterPassword:  masterPassword,
                sessionSecret:   sessionSecret,
                sessionDuration: sessionDuration,
                logger:          logger,
        }
}</span>

// VerifyPassword checks if the provided password matches the master password
func (s *Service) VerifyPassword(password string) bool <span class="cov0" title="0">{
        return subtle.ConstantTimeCompare([]byte(password), []byte(s.masterPassword)) == 1
}</span>

// UpdatePassword updates the master password (in-memory only, resets on restart)
// For persistent password storage, this would need to be stored in the database
func (s *Service) UpdatePassword(newPassword string) error <span class="cov0" title="0">{
        s.masterPassword = newPassword
        s.logger.Info("master password updated")
        return nil
}</span>

// CreateSession creates a new session and returns the session token
func (s *Service) CreateSession() (string, error) <span class="cov0" title="0">{
        // Generate random token
        tokenBytes := make([]byte, 32)
        if _, err := rand.Read(tokenBytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate session token: %w", err)
        }</span>
        <span class="cov0" title="0">token := base64.URLEncoding.EncodeToString(tokenBytes)

        // Hash token for storage
        tokenHash := hashToken(token)

        // Generate session ID
        idBytes := make([]byte, 16)
        if _, err := rand.Read(idBytes); err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate session ID: %w", err)
        }</span>
        <span class="cov0" title="0">sessionID := hex.EncodeToString(idBytes)

        // Calculate expiry
        expiresAt := time.Now().Add(s.sessionDuration)

        // Store session
        _, err := s.db.Exec(
                "INSERT INTO sessions (id, token_hash, expires_at) VALUES (?, ?, ?)",
                sessionID, tokenHash, expiresAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to create session: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("session created", "session_id", sessionID, "expires_at", expiresAt)
        return token, nil</span>
}

// ValidateSession checks if a session token is valid
func (s *Service) ValidateSession(token string) bool <span class="cov0" title="0">{
        if token == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">tokenHash := hashToken(token)

        var expiresAt time.Time
        err := s.db.QueryRow(
                "SELECT expires_at FROM sessions WHERE token_hash = ?",
                tokenHash,
        ).Scan(&amp;expiresAt)

        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if time.Now().After(expiresAt) </span><span class="cov0" title="0">{
                // Clean up expired session
                s.db.Exec("DELETE FROM sessions WHERE token_hash = ?", tokenHash)
                return false
        }</span>

        <span class="cov0" title="0">return true</span>
}

// InvalidateSession removes a session
func (s *Service) InvalidateSession(token string) error <span class="cov0" title="0">{
        tokenHash := hashToken(token)
        _, err := s.db.Exec("DELETE FROM sessions WHERE token_hash = ?", tokenHash)
        return err
}</span>

// CleanupExpiredSessions removes all expired sessions
func (s *Service) CleanupExpiredSessions() error <span class="cov0" title="0">{
        result, err := s.db.Exec("DELETE FROM sessions WHERE expires_at &lt; ?", time.Now())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">rows, _ := result.RowsAffected()
        if rows &gt; 0 </span><span class="cov0" title="0">{
                s.logger.Info("cleaned up expired sessions", "count", rows)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SetSessionCookie sets the session cookie on the response
func (s *Service) SetSessionCookie(w http.ResponseWriter, token string) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "snipo_session",
                Value:    token,
                Path:     "/",
                HttpOnly: true,
                Secure:   true,
                SameSite: http.SameSiteStrictMode,
                MaxAge:   int(s.sessionDuration.Seconds()),
        })
}</span>

// ClearSessionCookie clears the session cookie
func (s *Service) ClearSessionCookie(w http.ResponseWriter) <span class="cov0" title="0">{
        http.SetCookie(w, &amp;http.Cookie{
                Name:     "snipo_session",
                Value:    "",
                Path:     "/",
                HttpOnly: true,
                Secure:   true,
                SameSite: http.SameSiteStrictMode,
                MaxAge:   -1,
        })
}</span>

// GetSessionFromRequest extracts the session token from the request
func GetSessionFromRequest(r *http.Request) string <span class="cov0" title="0">{
        // Check cookie first
        cookie, err := r.Cookie("snipo_session")
        if err == nil &amp;&amp; cookie.Value != "" </span><span class="cov0" title="0">{
                return cookie.Value
        }</span>

        // Check Authorization header
        <span class="cov0" title="0">authHeader := r.Header.Get("Authorization")
        if strings.HasPrefix(authHeader, "Bearer ") </span><span class="cov0" title="0">{
                return strings.TrimPrefix(authHeader, "Bearer ")
        }</span>

        // Check X-API-Key header
        <span class="cov0" title="0">apiKey := r.Header.Get("X-API-Key")
        if apiKey != "" </span><span class="cov0" title="0">{
                return apiKey
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// hashToken creates a SHA256 hash of the token
func hashToken(token string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(token))
        return hex.EncodeToString(hash[:])
}</span>

// HashPassword creates an Argon2id hash of a password
func HashPassword(password string) (string, error) <span class="cov0" title="0">{
        salt := make([]byte, 16)
        if _, err := rand.Read(salt); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">hash := argon2.IDKey([]byte(password), salt, argonTime, argonMemory, argonThreads, argonKeyLen)

        // Encode as: $argon2id$salt$hash
        return fmt.Sprintf("$argon2id$%s$%s",
                base64.RawStdEncoding.EncodeToString(salt),
                base64.RawStdEncoding.EncodeToString(hash),
        ), nil</span>
}

// VerifyPasswordHash checks password against an Argon2id hash
func VerifyPasswordHash(password, encodedHash string) bool <span class="cov0" title="0">{
        parts := strings.Split(encodedHash, "$")
        if len(parts) != 4 || parts[1] != "argon2id" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">salt, err := base64.RawStdEncoding.DecodeString(parts[2])
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">hash, err := base64.RawStdEncoding.DecodeString(parts[3])
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">computedHash := argon2.IDKey([]byte(password), salt, argonTime, argonMemory, argonThreads, argonKeyLen)

        return subtle.ConstantTimeCompare(hash, computedHash) == 1</span>
}

// GenerateAPIToken creates a secure random API token
func GenerateAPIToken() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.URLEncoding.EncodeToString(bytes), nil</span>
}
</pre>
		
		<pre class="file" id="file12" style="display: none">package config

import (
        "crypto/rand"
        "encoding/base64"
        "errors"
        "os"
        "strconv"
        "time"
)

// Config holds all application configuration
type Config struct {
        Server   ServerConfig
        Database DatabaseConfig
        Auth     AuthConfig
        S3       S3Config
        Logging  LoggingConfig
}

// ServerConfig holds HTTP server settings
type ServerConfig struct {
        Host               string
        Port               int
        ReadTimeout        time.Duration
        WriteTimeout       time.Duration
        TrustProxy         bool
        MaxFilesPerSnippet int
}

// DatabaseConfig holds SQLite settings
type DatabaseConfig struct {
        Path            string
        MaxOpenConns    int
        BusyTimeout     int
        JournalMode     string
        SynchronousMode string
}

// AuthConfig holds authentication settings
type AuthConfig struct {
        MasterPassword  string
        SessionSecret   string
        SessionDuration time.Duration
        RateLimit       int
        RateLimitWindow time.Duration
}

// S3Config holds S3 storage settings
type S3Config struct {
        Enabled         bool
        Endpoint        string
        AccessKeyID     string
        SecretAccessKey string
        Bucket          string
        Region          string
        UseSSL          bool
}

// LoggingConfig holds logging settings
type LoggingConfig struct {
        Level  string
        Format string
}

// Load reads configuration from environment variables
func Load() (*Config, error) <span class="cov0" title="0">{
        cfg := &amp;Config{}

        // Server
        cfg.Server.Host = getEnv("SNIPO_HOST", "0.0.0.0")
        cfg.Server.Port = getEnvInt("SNIPO_PORT", 8080)
        cfg.Server.ReadTimeout = getEnvDuration("SNIPO_READ_TIMEOUT", 30*time.Second)
        cfg.Server.WriteTimeout = getEnvDuration("SNIPO_WRITE_TIMEOUT", 30*time.Second)
        cfg.Server.TrustProxy = getEnvBool("SNIPO_TRUST_PROXY", false)
        cfg.Server.MaxFilesPerSnippet = getEnvInt("SNIPO_MAX_FILES_PER_SNIPPET", 10)

        // Database
        cfg.Database.Path = getEnv("SNIPO_DB_PATH", "./data/snipo.db")
        cfg.Database.MaxOpenConns = getEnvInt("SNIPO_DB_MAX_CONNS", 1)
        cfg.Database.BusyTimeout = getEnvInt("SNIPO_DB_BUSY_TIMEOUT", 5000)
        cfg.Database.JournalMode = getEnv("SNIPO_DB_JOURNAL", "WAL")
        cfg.Database.SynchronousMode = getEnv("SNIPO_DB_SYNC", "NORMAL")

        // Auth
        cfg.Auth.MasterPassword = os.Getenv("SNIPO_MASTER_PASSWORD")
        if cfg.Auth.MasterPassword == "" </span><span class="cov0" title="0">{
                return nil, errors.New("SNIPO_MASTER_PASSWORD is required")
        }</span>

        <span class="cov0" title="0">sessionSecret := os.Getenv("SNIPO_SESSION_SECRET")
        if sessionSecret == "" </span><span class="cov0" title="0">{
                secret, err := generateSecret()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">sessionSecret = secret</span>
        }
        <span class="cov0" title="0">cfg.Auth.SessionSecret = sessionSecret
        cfg.Auth.SessionDuration = getEnvDuration("SNIPO_SESSION_DURATION", 168*time.Hour)
        cfg.Auth.RateLimit = getEnvInt("SNIPO_RATE_LIMIT", 100)
        cfg.Auth.RateLimitWindow = getEnvDuration("SNIPO_RATE_WINDOW", 1*time.Minute)

        // S3
        cfg.S3.Enabled = getEnvBool("SNIPO_S3_ENABLED", false)
        cfg.S3.Endpoint = os.Getenv("SNIPO_S3_ENDPOINT")
        cfg.S3.AccessKeyID = os.Getenv("SNIPO_S3_ACCESS_KEY")
        cfg.S3.SecretAccessKey = os.Getenv("SNIPO_S3_SECRET_KEY")
        cfg.S3.Bucket = os.Getenv("SNIPO_S3_BUCKET")
        cfg.S3.Region = getEnv("SNIPO_S3_REGION", "us-east-1")
        cfg.S3.UseSSL = getEnvBool("SNIPO_S3_SSL", true)

        // Logging
        cfg.Logging.Level = getEnv("SNIPO_LOG_LEVEL", "info")
        cfg.Logging.Format = getEnv("SNIPO_LOG_FORMAT", "json")

        return cfg, nil</span>
}

// Addr returns the server address string
func (c *ServerConfig) Addr() string <span class="cov0" title="0">{
        return c.Host + ":" + strconv.Itoa(c.Port)
}</span>

// Helper functions

func getEnv(key, defaultVal string) string <span class="cov0" title="0">{
        if val := os.Getenv(key); val != "" </span><span class="cov0" title="0">{
                return val
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

func getEnvInt(key string, defaultVal int) int <span class="cov0" title="0">{
        if val := os.Getenv(key); val != "" </span><span class="cov0" title="0">{
                if i, err := strconv.Atoi(val); err == nil </span><span class="cov0" title="0">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return defaultVal</span>
}

func getEnvBool(key string, defaultVal bool) bool <span class="cov0" title="0">{
        if val := os.Getenv(key); val != "" </span><span class="cov0" title="0">{
                return val == "true" || val == "1" || val == "yes"
        }</span>
        <span class="cov0" title="0">return defaultVal</span>
}

func getEnvDuration(key string, defaultVal time.Duration) time.Duration <span class="cov0" title="0">{
        if val := os.Getenv(key); val != "" </span><span class="cov0" title="0">{
                if d, err := time.ParseDuration(val); err == nil </span><span class="cov0" title="0">{
                        return d
                }</span>
        }
        <span class="cov0" title="0">return defaultVal</span>
}

func generateSecret() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return base64.URLEncoding.EncodeToString(bytes), nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "log/slog"
        "os"
        "path/filepath"

        _ "modernc.org/sqlite"
)

// DB wraps the sql.DB with additional functionality
type DB struct {
        *sql.DB
        logger *slog.Logger
}

// Config holds database configuration
type Config struct {
        Path            string
        MaxOpenConns    int
        BusyTimeout     int
        JournalMode     string
        SynchronousMode string
}

// New creates a new database connection
func New(cfg Config, logger *slog.Logger) (*DB, error) <span class="cov0" title="0">{
        // Ensure directory exists
        dir := filepath.Dir(cfg.Path)
        if dir != "" &amp;&amp; dir != "." </span><span class="cov0" title="0">{
                if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to create database directory: %w", err)
                }</span>
        }

        // Build connection string with pragmas
        <span class="cov0" title="0">dsn := fmt.Sprintf("%s?_busy_timeout=%d&amp;_journal_mode=%s&amp;_synchronous=%s&amp;_foreign_keys=ON",
                cfg.Path,
                cfg.BusyTimeout,
                cfg.JournalMode,
                cfg.SynchronousMode,
        )

        db, err := sql.Open("sqlite", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database: %w", err)
        }</span>

        // Set connection pool settings
        <span class="cov0" title="0">db.SetMaxOpenConns(cfg.MaxOpenConns)

        // Verify connection
        if err := db.Ping(); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        // Apply additional pragmas
        <span class="cov0" title="0">pragmas := []string{
                "PRAGMA cache_size = -2000",    // 2MB cache
                "PRAGMA temp_store = MEMORY",   // Temp tables in memory
                "PRAGMA mmap_size = 268435456", // 256MB memory-mapped I/O
        }

        for _, pragma := range pragmas </span><span class="cov0" title="0">{
                if _, err := db.Exec(pragma); err != nil </span><span class="cov0" title="0">{
                        logger.Warn("failed to set pragma", "pragma", pragma, "error", err)
                }</span>
        }

        <span class="cov0" title="0">logger.Info("database connected", "path", cfg.Path)

        return &amp;DB{DB: db, logger: logger}, nil</span>
}

// Migrate runs all pending migrations
func (db *DB) Migrate(ctx context.Context) error <span class="cov0" title="0">{
        // Create migrations table if not exists
        _, err := db.ExecContext(ctx, `
                CREATE TABLE IF NOT EXISTS schema_migrations (
                        version INTEGER PRIMARY KEY,
                        name TEXT NOT NULL,
                        applied_at DATETIME DEFAULT CURRENT_TIMESTAMP
                )
        `)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create migrations table: %w", err)
        }</span>

        // Get current version
        <span class="cov0" title="0">var currentVersion int
        row := db.QueryRowContext(ctx, "SELECT COALESCE(MAX(version), 0) FROM schema_migrations")
        if err := row.Scan(&amp;currentVersion); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get current migration version: %w", err)
        }</span>

        <span class="cov0" title="0">db.logger.Info("current schema version", "version", currentVersion)

        // Run migrations
        migrations := getMigrations()
        for _, m := range migrations </span><span class="cov0" title="0">{
                if m.Version &lt;= currentVersion </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">db.logger.Info("applying migration", "version", m.Version, "name", m.Name)

                // Execute migration in a transaction
                tx, err := db.BeginTx(ctx, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to begin transaction: %w", err)
                }</span>

                <span class="cov0" title="0">if _, err := tx.ExecContext(ctx, m.SQL); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("failed to apply migration %d (%s): %w", m.Version, m.Name, err)
                }</span>

                // Record migration
                <span class="cov0" title="0">if _, err := tx.ExecContext(ctx,
                        "INSERT INTO schema_migrations (version, name) VALUES (?, ?)",
                        m.Version, m.Name,
                ); err != nil </span><span class="cov0" title="0">{
                        tx.Rollback()
                        return fmt.Errorf("failed to record migration: %w", err)
                }</span>

                <span class="cov0" title="0">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to commit migration: %w", err)
                }</span>

                <span class="cov0" title="0">db.logger.Info("migration applied", "version", m.Version, "name", m.Name)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// Close closes the database connection
func (db *DB) Close() error <span class="cov0" title="0">{
        db.logger.Info("closing database connection")
        return db.DB.Close()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package database

// Migration represents a database migration
type Migration struct {
        Version int
        Name    string
        SQL     string
}

// Initial schema SQL
const initialSchemaSQL = `
-- Snipo Initial Schema
-- Version: 1

-- Snippets table - core entity
CREATE TABLE IF NOT EXISTS snippets (
    id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(8)))),
    title TEXT NOT NULL,
    description TEXT DEFAULT '',
    content TEXT NOT NULL,
    language TEXT DEFAULT 'plaintext',
    is_favorite INTEGER DEFAULT 0,
    is_public INTEGER DEFAULT 0,
    view_count INTEGER DEFAULT 0,
    s3_key TEXT DEFAULT NULL,
    checksum TEXT DEFAULT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Tags table
CREATE TABLE IF NOT EXISTS tags (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT UNIQUE NOT NULL,
    color TEXT DEFAULT '#6366f1',
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Snippet-Tag junction table
CREATE TABLE IF NOT EXISTS snippet_tags (
    snippet_id TEXT NOT NULL,
    tag_id INTEGER NOT NULL,
    PRIMARY KEY (snippet_id, tag_id),
    FOREIGN KEY (snippet_id) REFERENCES snippets(id) ON DELETE CASCADE,
    FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
);

-- Folders/Collections for organization
CREATE TABLE IF NOT EXISTS folders (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    parent_id INTEGER DEFAULT NULL,
    icon TEXT DEFAULT 'folder',
    sort_order INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (parent_id) REFERENCES folders(id) ON DELETE CASCADE
);

-- Snippet-Folder relationship
CREATE TABLE IF NOT EXISTS snippet_folders (
    snippet_id TEXT NOT NULL,
    folder_id INTEGER NOT NULL,
    PRIMARY KEY (snippet_id, folder_id),
    FOREIGN KEY (snippet_id) REFERENCES snippets(id) ON DELETE CASCADE,
    FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE CASCADE
);

-- Snippet files (multi-file support)
CREATE TABLE IF NOT EXISTS snippet_files (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    snippet_id TEXT NOT NULL,
    filename TEXT NOT NULL,
    content TEXT NOT NULL,
    language TEXT DEFAULT 'plaintext',
    sort_order INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (snippet_id) REFERENCES snippets(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_snippet_files_snippet ON snippet_files(snippet_id);

-- Application settings (single row)
CREATE TABLE IF NOT EXISTS settings (
    id INTEGER PRIMARY KEY CHECK (id = 1),
    app_name TEXT DEFAULT 'snipo',
    custom_css TEXT DEFAULT '',
    theme TEXT DEFAULT 'auto',
    default_language TEXT DEFAULT 'plaintext',
    s3_enabled INTEGER DEFAULT 0,
    s3_endpoint TEXT DEFAULT '',
    s3_bucket TEXT DEFAULT '',
    s3_region TEXT DEFAULT 'us-east-1',
    backup_encryption_enabled INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- API tokens for external access
CREATE TABLE IF NOT EXISTS api_tokens (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    token_hash TEXT UNIQUE NOT NULL,
    permissions TEXT DEFAULT 'read',
    last_used_at DATETIME DEFAULT NULL,
    expires_at DATETIME DEFAULT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Sessions table for web authentication
CREATE TABLE IF NOT EXISTS sessions (
    id TEXT PRIMARY KEY,
    token_hash TEXT UNIQUE NOT NULL,
    expires_at DATETIME NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_snippets_language ON snippets(language);
CREATE INDEX IF NOT EXISTS idx_snippets_favorite ON snippets(is_favorite);
CREATE INDEX IF NOT EXISTS idx_snippets_public ON snippets(is_public);
CREATE INDEX IF NOT EXISTS idx_snippets_created ON snippets(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_snippets_updated ON snippets(updated_at DESC);
CREATE INDEX IF NOT EXISTS idx_tags_name ON tags(name);
CREATE INDEX IF NOT EXISTS idx_folders_parent ON folders(parent_id);
CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at);

-- Full-text search (external content FTS5 table)
CREATE VIRTUAL TABLE IF NOT EXISTS snippets_fts USING fts5(
    snippet_id,
    title,
    description,
    content,
    content='snippets',
    content_rowid='rowid'
);

-- Triggers to keep FTS in sync
CREATE TRIGGER IF NOT EXISTS snippets_ai AFTER INSERT ON snippets BEGIN
    INSERT INTO snippets_fts(rowid, snippet_id, title, description, content)
    VALUES (NEW.rowid, NEW.id, NEW.title, NEW.description, NEW.content);
END;

CREATE TRIGGER IF NOT EXISTS snippets_ad AFTER DELETE ON snippets BEGIN
    INSERT INTO snippets_fts(snippets_fts, rowid, snippet_id, title, description, content)
    VALUES('delete', OLD.rowid, OLD.id, OLD.title, OLD.description, OLD.content);
END;

CREATE TRIGGER IF NOT EXISTS snippets_au AFTER UPDATE ON snippets BEGIN
    INSERT INTO snippets_fts(snippets_fts, rowid, snippet_id, title, description, content)
    VALUES('delete', OLD.rowid, OLD.id, OLD.title, OLD.description, OLD.content);
    INSERT INTO snippets_fts(rowid, snippet_id, title, description, content)
    VALUES (NEW.rowid, NEW.id, NEW.title, NEW.description, NEW.content);
END;

-- Insert default settings row
INSERT OR IGNORE INTO settings (id) VALUES (1);
`

// Migration 2: Add snippet_files table for multi-file support
const addSnippetFilesSQL = `
-- Snippet files (multi-file support)
CREATE TABLE IF NOT EXISTS snippet_files (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    snippet_id TEXT NOT NULL,
    filename TEXT NOT NULL,
    content TEXT NOT NULL,
    language TEXT DEFAULT 'plaintext',
    sort_order INTEGER DEFAULT 0,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (snippet_id) REFERENCES snippets(id) ON DELETE CASCADE
);

CREATE INDEX IF NOT EXISTS idx_snippet_files_snippet ON snippet_files(snippet_id);
`

// getMigrations returns all available migrations in order
func getMigrations() []Migration <span class="cov0" title="0">{
        return []Migration{
                {Version: 1, Name: "initial_schema", SQL: initialSchemaSQL},
                {Version: 2, Name: "add_snippet_files", SQL: addSnippetFilesSQL},
        }
}</span>
</pre>
		
		<pre class="file" id="file15" style="display: none">package models

import (
        "time"
)

// SnippetFile represents a file within a snippet
type SnippetFile struct {
        ID        int64     `json:"id"`
        SnippetID string    `json:"snippet_id,omitempty"`
        Filename  string    `json:"filename"`
        Content   string    `json:"content"`
        Language  string    `json:"language"`
        SortOrder int       `json:"sort_order"`
        CreatedAt time.Time `json:"created_at,omitempty"`
        UpdatedAt time.Time `json:"updated_at,omitempty"`
}

// Snippet represents a code snippet
type Snippet struct {
        ID          string    `json:"id"`
        Title       string    `json:"title"`
        Description string    `json:"description"`
        Content     string    `json:"content"`  // Primary/legacy content (first file)
        Language    string    `json:"language"` // Primary/legacy language
        IsFavorite  bool      `json:"is_favorite"`
        IsPublic    bool      `json:"is_public"`
        ViewCount   int       `json:"view_count"`
        S3Key       *string   `json:"s3_key,omitempty"`
        Checksum    *string   `json:"checksum,omitempty"`
        CreatedAt   time.Time `json:"created_at"`
        UpdatedAt   time.Time `json:"updated_at"`

        // Relationships (populated when needed)
        Tags    []Tag         `json:"tags,omitempty"`
        Folders []Folder      `json:"folders,omitempty"`
        Files   []SnippetFile `json:"files,omitempty"` // Multi-file support
}

// SnippetFileInput represents input for a file within a snippet
type SnippetFileInput struct {
        ID       int64  `json:"id,omitempty"` // 0 for new files
        Filename string `json:"filename"`
        Content  string `json:"content"`
        Language string `json:"language"`
}

// SnippetInput represents input for creating/updating a snippet
type SnippetInput struct {
        Title       string             `json:"title"`
        Description string             `json:"description"`
        Content     string             `json:"content"`  // Legacy single-file content
        Language    string             `json:"language"` // Legacy single-file language
        Tags        []string           `json:"tags,omitempty"`
        FolderID    *int64             `json:"folder_id,omitempty"`
        IsPublic    bool               `json:"is_public"`
        Files       []SnippetFileInput `json:"files,omitempty"` // Multi-file support
}

// SnippetFilter represents filter options for listing snippets
type SnippetFilter struct {
        Query      string
        Language   string
        TagID      int64
        FolderID   int64
        IsFavorite *bool
        IsPublic   *bool
        Page       int
        Limit      int
        SortBy     string
        SortOrder  string
}

// DefaultSnippetFilter returns default filter values
func DefaultSnippetFilter() SnippetFilter <span class="cov0" title="0">{
        return SnippetFilter{
                Page:      1,
                Limit:     20,
                SortBy:    "updated_at",
                SortOrder: "desc",
        }
}</span>

// Tag represents a tag for organizing snippets
type Tag struct {
        ID           int64     `json:"id"`
        Name         string    `json:"name"`
        Color        string    `json:"color"`
        CreatedAt    time.Time `json:"created_at"`
        SnippetCount int       `json:"snippet_count,omitempty"`
}

// TagInput represents input for creating/updating a tag
type TagInput struct {
        Name  string `json:"name"`
        Color string `json:"color"`
}

// Folder represents a folder for organizing snippets
type Folder struct {
        ID           int64     `json:"id"`
        Name         string    `json:"name"`
        ParentID     *int64    `json:"parent_id,omitempty"`
        Icon         string    `json:"icon"`
        SortOrder    int       `json:"sort_order"`
        CreatedAt    time.Time `json:"created_at"`
        SnippetCount int       `json:"snippet_count,omitempty"`
        Children     []Folder  `json:"children,omitempty"`
}

// FolderInput represents input for creating/updating a folder
type FolderInput struct {
        Name      string `json:"name"`
        ParentID  *int64 `json:"parent_id,omitempty"`
        Icon      string `json:"icon,omitempty"`
        SortOrder int    `json:"sort_order,omitempty"`
}

// APIToken represents an API token for external access
type APIToken struct {
        ID          int64      `json:"id"`
        Name        string     `json:"name"`
        Token       string     `json:"token,omitempty"` // Only returned on creation
        TokenHash   string     `json:"-"`
        Permissions string     `json:"permissions"`
        LastUsedAt  *time.Time `json:"last_used_at,omitempty"`
        ExpiresAt   *time.Time `json:"expires_at,omitempty"`
        CreatedAt   time.Time  `json:"created_at"`
}

// APITokenInput struct here represents input for creating an API token
type APITokenInput struct {
        Name        string     `json:"name"`
        Permissions string     `json:"permissions"` // "read", "write", "admin"
        ExpiresAt   *time.Time `json:"expires_at,omitempty"`
}

// Pagination holds pagination info for list responses (  )
type Pagination struct {
        Page       int `json:"page"`
        Limit      int `json:"limit"`
        Total      int `json:"total"`
        TotalPages int `json:"total_pages"`
}

// SnippetListResponse represents a paginated list of snippets
type SnippetListResponse struct {
        Data       []Snippet  `json:"data"`
        Pagination Pagination `json:"pagination"`
}

// BackupData represents a complete backup of all data
type BackupData struct {
        Version   string    `json:"version"`
        CreatedAt time.Time `json:"created_at"`
        Snippets  []Snippet `json:"snippets"`
        Tags      []Tag     `json:"tags"`
        Folders   []Folder  `json:"folders"`
}

// ExportOptions configures backup export behavior
type ExportOptions struct {
        Format   string `json:"format"`   // "json" or "zip"
        Password string `json:"password"` // Optional encryption password
}

// ImportOptions configures backup import behavior
type ImportOptions struct {
        Strategy string `json:"strategy"` // "replace", "merge", "skip"
        Password string `json:"password"` // Decryption password if encrypted
}

// ImportResult contains the results of an import operation
type ImportResult struct {
        SnippetsImported int      `json:"snippets_imported"`
        TagsImported     int      `json:"tags_imported"`
        FoldersImported  int      `json:"folders_imported"`
        Errors           []string `json:"errors,omitempty"`
}

// S3BackupInfo represents info about a backup stored in S3
type S3BackupInfo struct {
        Key          string    `json:"key"`
        Size         int64     `json:"size"`
        LastModified time.Time `json:"last_modified"`
}

// S3SyncResult contains the results of an S3 sync operation
type S3SyncResult struct {
        Uploaded   int       `json:"uploaded"`
        Errors     []string  `json:"errors,omitempty"`
        StartedAt  time.Time `json:"started_at"`
        FinishedAt time.Time `json:"finished_at"`
}

// S3RestoreResult contains the results of an S3 restore operation
type S3RestoreResult struct {
        Restored   int       `json:"restored"`
        Errors     []string  `json:"errors,omitempty"`
        StartedAt  time.Time `json:"started_at"`
        FinishedAt time.Time `json:"finished_at"`
}
</pre>
		
		<pre class="file" id="file16" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/MohamedElashri/snipo/internal/models"
)

// FolderRepository handles folder database operations
type FolderRepository struct {
        db *sql.DB
}

// NewFolderRepository creates a new folder repository
func NewFolderRepository(db *sql.DB) *FolderRepository <span class="cov9" title="16">{
        return &amp;FolderRepository{db: db}
}</span>

// Create creates a new folder
func (r *FolderRepository) Create(ctx context.Context, input *models.FolderInput) (*models.Folder, error) <span class="cov10" title="22">{
        icon := input.Icon
        if icon == "" </span><span class="cov9" title="21">{
                icon = "folder"
        }</span>

        <span class="cov10" title="22">query := `
                INSERT INTO folders (name, parent_id, icon, sort_order)
                VALUES (?, ?, ?, ?)
                RETURNING id, name, parent_id, icon, sort_order, created_at
        `

        folder := &amp;models.Folder{}
        err := r.db.QueryRowContext(ctx, query, input.Name, input.ParentID, icon, input.SortOrder).Scan(
                &amp;folder.ID,
                &amp;folder.Name,
                &amp;folder.ParentID,
                &amp;folder.Icon,
                &amp;folder.SortOrder,
                &amp;folder.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create folder: %w", err)
        }</span>

        <span class="cov10" title="22">return folder, nil</span>
}

// GetByID retrieves a folder by ID
func (r *FolderRepository) GetByID(ctx context.Context, id int64) (*models.Folder, error) <span class="cov4" title="3">{
        query := `SELECT id, name, parent_id, icon, sort_order, created_at FROM folders WHERE id = ?`

        folder := &amp;models.Folder{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;folder.ID,
                &amp;folder.Name,
                &amp;folder.ParentID,
                &amp;folder.Icon,
                &amp;folder.SortOrder,
                &amp;folder.CreatedAt,
        )
        if err != nil </span><span class="cov3" title="2">{
                if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get folder: %w", err)</span>
        }

        <span class="cov1" title="1">return folder, nil</span>
}

// List retrieves all folders (flat list) with snippet counts
func (r *FolderRepository) List(ctx context.Context) ([]models.Folder, error) <span class="cov3" title="2">{
        query := `
                SELECT f.id, f.name, f.parent_id, f.icon, f.sort_order, f.created_at,
                       (SELECT COUNT(*) FROM snippet_folders sf 
                        INNER JOIN snippets s ON s.id = sf.snippet_id 
                        WHERE sf.folder_id = f.id) as snippet_count
                FROM folders f
                ORDER BY f.sort_order ASC, f.name ASC
        `

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list folders: %w", err)
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var folders []models.Folder
        for rows.Next() </span><span class="cov6" title="7">{
                var folder models.Folder
                if err := rows.Scan(
                        &amp;folder.ID,
                        &amp;folder.Name,
                        &amp;folder.ParentID,
                        &amp;folder.Icon,
                        &amp;folder.SortOrder,
                        &amp;folder.CreatedAt,
                        &amp;folder.SnippetCount,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan folder: %w", err)
                }</span>
                <span class="cov6" title="7">folders = append(folders, folder)</span>
        }

        <span class="cov3" title="2">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating folders: %w", err)
        }</span>

        <span class="cov3" title="2">return folders, nil</span>
}

// ListTree retrieves folders as a tree structure
func (r *FolderRepository) ListTree(ctx context.Context) ([]models.Folder, error) <span class="cov1" title="1">{
        folders, err := r.List(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build tree from flat list
        <span class="cov1" title="1">return buildFolderTree(folders), nil</span>
}

// buildFolderTree converts a flat list of folders into a tree structure
func buildFolderTree(folders []models.Folder) []models.Folder <span class="cov1" title="1">{
        // Create a map for quick lookup
        folderMap := make(map[int64]*models.Folder)
        for i := range folders </span><span class="cov5" title="4">{
                folders[i].Children = []models.Folder{}
                folderMap[folders[i].ID] = &amp;folders[i]
        }</span>

        // Build tree
        <span class="cov1" title="1">var roots []models.Folder
        for i := range folders </span><span class="cov5" title="4">{
                if folders[i].ParentID == nil </span><span class="cov3" title="2">{
                        roots = append(roots, folders[i])
                }</span> else<span class="cov3" title="2"> {
                        parent, exists := folderMap[*folders[i].ParentID]
                        if exists </span><span class="cov3" title="2">{
                                parent.Children = append(parent.Children, folders[i])
                        }</span> else<span class="cov0" title="0"> {
                                // Orphan folder, add to roots
                                roots = append(roots, folders[i])
                        }</span>
                }
        }

        // Update roots with children from map
        <span class="cov1" title="1">for i := range roots </span><span class="cov3" title="2">{
                if mapped, exists := folderMap[roots[i].ID]; exists </span><span class="cov3" title="2">{
                        roots[i].Children = mapped.Children
                }</span>
        }

        <span class="cov1" title="1">return roots</span>
}

// Update updates an existing folder
func (r *FolderRepository) Update(ctx context.Context, id int64, input *models.FolderInput) (*models.Folder, error) <span class="cov3" title="2">{
        icon := input.Icon
        if icon == "" </span><span class="cov1" title="1">{
                icon = "folder"
        }</span>

        <span class="cov3" title="2">query := `
                UPDATE folders
                SET name = ?, parent_id = ?, icon = ?, sort_order = ?
                WHERE id = ?
                RETURNING id, name, parent_id, icon, sort_order, created_at
        `

        folder := &amp;models.Folder{}
        err := r.db.QueryRowContext(ctx, query, input.Name, input.ParentID, icon, input.SortOrder, id).Scan(
                &amp;folder.ID,
                &amp;folder.Name,
                &amp;folder.ParentID,
                &amp;folder.Icon,
                &amp;folder.SortOrder,
                &amp;folder.CreatedAt,
        )
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update folder: %w", err)</span>
        }

        <span class="cov1" title="1">return folder, nil</span>
}

// Delete deletes a folder
func (r *FolderRepository) Delete(ctx context.Context, id int64) error <span class="cov3" title="2">{
        result, err := r.db.ExecContext(ctx, `DELETE FROM folders WHERE id = ?`, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete folder: %w", err)
        }</span>

        <span class="cov3" title="2">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov3" title="2">if rows == 0 </span><span class="cov1" title="1">{
                return ErrNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// Move moves a folder to a new parent
func (r *FolderRepository) Move(ctx context.Context, id int64, newParentID *int64) (*models.Folder, error) <span class="cov4" title="3">{
        // Check for circular reference
        if newParentID != nil </span><span class="cov3" title="2">{
                if err := r.checkCircularReference(ctx, id, *newParentID); err != nil </span><span class="cov1" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov3" title="2">query := `
                UPDATE folders
                SET parent_id = ?
                WHERE id = ?
                RETURNING id, name, parent_id, icon, sort_order, created_at
        `

        folder := &amp;models.Folder{}
        err := r.db.QueryRowContext(ctx, query, newParentID, id).Scan(
                &amp;folder.ID,
                &amp;folder.Name,
                &amp;folder.ParentID,
                &amp;folder.Icon,
                &amp;folder.SortOrder,
                &amp;folder.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to move folder: %w", err)</span>
        }

        <span class="cov3" title="2">return folder, nil</span>
}

// checkCircularReference checks if moving a folder would create a circular reference
func (r *FolderRepository) checkCircularReference(ctx context.Context, folderID, newParentID int64) error <span class="cov3" title="2">{
        // Check if newParentID is a descendant of folderID
        currentID := newParentID
        for </span><span class="cov3" title="2">{
                var parentID *int64
                err := r.db.QueryRowContext(ctx, `SELECT parent_id FROM folders WHERE id = ?`, currentID).Scan(&amp;parentID)
                if err != nil </span><span class="cov0" title="0">{
                        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                                return nil // Parent doesn't exist, no circular reference
                        }</span>
                        <span class="cov0" title="0">return fmt.Errorf("failed to check circular reference: %w", err)</span>
                }

                <span class="cov3" title="2">if parentID == nil </span><span class="cov1" title="1">{
                        return nil // Reached root, no circular reference
                }</span>

                <span class="cov1" title="1">if *parentID == folderID </span><span class="cov1" title="1">{
                        return fmt.Errorf("cannot move folder: would create circular reference")
                }</span>

                <span class="cov0" title="0">currentID = *parentID</span>
        }
}

// GetFolderSnippetCount returns the number of snippets in a folder
func (r *FolderRepository) GetFolderSnippetCount(ctx context.Context, folderID int64) (int, error) <span class="cov1" title="1">{
        var count int
        err := r.db.QueryRowContext(ctx,
                `SELECT COUNT(*) FROM snippet_folders WHERE folder_id = ?`,
                folderID,
        ).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count snippets in folder: %w", err)
        }</span>
        <span class="cov1" title="1">return count, nil</span>
}

// GetSnippetFolders retrieves all folders for a snippet
func (r *FolderRepository) GetSnippetFolders(ctx context.Context, snippetID string) ([]models.Folder, error) <span class="cov3" title="2">{
        query := `
                SELECT f.id, f.name, f.parent_id, f.icon, f.sort_order, f.created_at
                FROM folders f
                JOIN snippet_folders sf ON f.id = sf.folder_id
                WHERE sf.snippet_id = ?
                ORDER BY f.name ASC
        `

        rows, err := r.db.QueryContext(ctx, query, snippetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get snippet folders: %w", err)
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var folders []models.Folder
        for rows.Next() </span><span class="cov1" title="1">{
                var folder models.Folder
                if err := rows.Scan(
                        &amp;folder.ID,
                        &amp;folder.Name,
                        &amp;folder.ParentID,
                        &amp;folder.Icon,
                        &amp;folder.SortOrder,
                        &amp;folder.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan folder: %w", err)
                }</span>
                <span class="cov1" title="1">folders = append(folders, folder)</span>
        }

        <span class="cov3" title="2">return folders, nil</span>
}

// SetSnippetFolder sets the folder for a snippet
func (r *FolderRepository) SetSnippetFolder(ctx context.Context, snippetID string, folderID *int64) error <span class="cov7" title="8">{
        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov7" title="8">defer tx.Rollback()

        // Remove existing folder associations
        _, err = tx.ExecContext(ctx, `DELETE FROM snippet_folders WHERE snippet_id = ?`, snippetID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove existing folders: %w", err)
        }</span>

        // Add new folder association if provided
        <span class="cov7" title="8">if folderID != nil </span><span class="cov6" title="7">{
                _, err = tx.ExecContext(ctx,
                        `INSERT INTO snippet_folders (snippet_id, folder_id) VALUES (?, ?)`,
                        snippetID, *folderID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to set snippet folder: %w", err)
                }</span>
        }

        <span class="cov7" title="8">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov7" title="8">return nil</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/MohamedElashri/snipo/internal/models"
)

// SnippetFileRepository handles snippet file database operations
type SnippetFileRepository struct {
        db *sql.DB
}

// NewSnippetFileRepository creates a new snippet file repository
func NewSnippetFileRepository(db *sql.DB) *SnippetFileRepository <span class="cov0" title="0">{
        return &amp;SnippetFileRepository{db: db}
}</span>

// GetBySnippetID retrieves all files for a snippet
func (r *SnippetFileRepository) GetBySnippetID(ctx context.Context, snippetID string) ([]models.SnippetFile, error) <span class="cov0" title="0">{
        query := `
                SELECT id, snippet_id, filename, content, language, sort_order, created_at, updated_at
                FROM snippet_files
                WHERE snippet_id = ?
                ORDER BY sort_order, id
        `

        rows, err := r.db.QueryContext(ctx, query, snippetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get snippet files: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var files []models.SnippetFile
        for rows.Next() </span><span class="cov0" title="0">{
                var f models.SnippetFile
                if err := rows.Scan(
                        &amp;f.ID,
                        &amp;f.SnippetID,
                        &amp;f.Filename,
                        &amp;f.Content,
                        &amp;f.Language,
                        &amp;f.SortOrder,
                        &amp;f.CreatedAt,
                        &amp;f.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan snippet file: %w", err)
                }</span>
                <span class="cov0" title="0">files = append(files, f)</span>
        }

        <span class="cov0" title="0">return files, nil</span>
}

// Create creates a new snippet file
func (r *SnippetFileRepository) Create(ctx context.Context, snippetID string, file *models.SnippetFileInput, sortOrder int) (*models.SnippetFile, error) <span class="cov0" title="0">{
        query := `
                INSERT INTO snippet_files (snippet_id, filename, content, language, sort_order)
                VALUES (?, ?, ?, ?, ?)
                RETURNING id, snippet_id, filename, content, language, sort_order, created_at, updated_at
        `

        var f models.SnippetFile
        err := r.db.QueryRowContext(ctx, query,
                snippetID,
                file.Filename,
                file.Content,
                file.Language,
                sortOrder,
        ).Scan(
                &amp;f.ID,
                &amp;f.SnippetID,
                &amp;f.Filename,
                &amp;f.Content,
                &amp;f.Language,
                &amp;f.SortOrder,
                &amp;f.CreatedAt,
                &amp;f.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create snippet file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;f, nil</span>
}

// Update updates an existing snippet file
func (r *SnippetFileRepository) Update(ctx context.Context, file *models.SnippetFileInput, sortOrder int) (*models.SnippetFile, error) <span class="cov0" title="0">{
        query := `
                UPDATE snippet_files
                SET filename = ?, content = ?, language = ?, sort_order = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
                RETURNING id, snippet_id, filename, content, language, sort_order, created_at, updated_at
        `

        var f models.SnippetFile
        err := r.db.QueryRowContext(ctx, query,
                file.Filename,
                file.Content,
                file.Language,
                sortOrder,
                file.ID,
        ).Scan(
                &amp;f.ID,
                &amp;f.SnippetID,
                &amp;f.Filename,
                &amp;f.Content,
                &amp;f.Language,
                &amp;f.SortOrder,
                &amp;f.CreatedAt,
                &amp;f.UpdatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update snippet file: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;f, nil</span>
}

// Delete deletes a snippet file
func (r *SnippetFileRepository) Delete(ctx context.Context, fileID int64) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx, "DELETE FROM snippet_files WHERE id = ?", fileID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete snippet file: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// DeleteBySnippetID deletes all files for a snippet
func (r *SnippetFileRepository) DeleteBySnippetID(ctx context.Context, snippetID string) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx, "DELETE FROM snippet_files WHERE snippet_id = ?", snippetID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete snippet files: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// SyncFiles synchronizes files for a snippet (creates, updates, deletes as needed)
func (r *SnippetFileRepository) SyncFiles(ctx context.Context, snippetID string, files []models.SnippetFileInput) ([]models.SnippetFile, error) <span class="cov0" title="0">{
        // Get existing files
        existing, err := r.GetBySnippetID(ctx, snippetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Build map of existing file IDs
        <span class="cov0" title="0">existingMap := make(map[int64]bool)
        for _, f := range existing </span><span class="cov0" title="0">{
                existingMap[f.ID] = true
        }</span>

        // Track which IDs are in the input
        <span class="cov0" title="0">inputIDs := make(map[int64]bool)
        var result []models.SnippetFile

        for i, file := range files </span><span class="cov0" title="0">{
                if file.ID &gt; 0 </span><span class="cov0" title="0">{
                        // Update existing file
                        inputIDs[file.ID] = true
                        updated, err := r.Update(ctx, &amp;file, i)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result = append(result, *updated)</span>
                } else<span class="cov0" title="0"> {
                        // Create new file
                        created, err := r.Create(ctx, snippetID, &amp;file, i)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result = append(result, *created)</span>
                }
        }

        // Delete files that are no longer in the input
        <span class="cov0" title="0">for id := range existingMap </span><span class="cov0" title="0">{
                if !inputIDs[id] </span><span class="cov0" title="0">{
                        if err := r.Delete(ctx, id); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
        }

        <span class="cov0" title="0">return result, nil</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"
        "strings"

        "github.com/MohamedElashri/snipo/internal/models"
)

// SnippetRepository handles snippet database operations
type SnippetRepository struct {
        db *sql.DB
}

// NewSnippetRepository creates a new snippet repository
func NewSnippetRepository(db *sql.DB) *SnippetRepository <span class="cov8" title="20">{
        return &amp;SnippetRepository{db: db}
}</span>

// Create inserts a new snippet
func (r *SnippetRepository) Create(ctx context.Context, input *models.SnippetInput) (*models.Snippet, error) <span class="cov10" title="43">{
        query := `
                INSERT INTO snippets (title, description, content, language, is_public)
                VALUES (?, ?, ?, ?, ?)
                RETURNING id, title, description, content, language, is_favorite, is_public, 
                          view_count, s3_key, checksum, created_at, updated_at
        `

        snippet := &amp;models.Snippet{}
        err := r.db.QueryRowContext(ctx, query,
                input.Title,
                input.Description,
                input.Content,
                input.Language,
                input.IsPublic,
        ).Scan(
                &amp;snippet.ID,
                &amp;snippet.Title,
                &amp;snippet.Description,
                &amp;snippet.Content,
                &amp;snippet.Language,
                &amp;snippet.IsFavorite,
                &amp;snippet.IsPublic,
                &amp;snippet.ViewCount,
                &amp;snippet.S3Key,
                &amp;snippet.Checksum,
                &amp;snippet.CreatedAt,
                &amp;snippet.UpdatedAt,
        )

        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create snippet: %w", err)
        }</span>

        <span class="cov10" title="43">return snippet, nil</span>
}

// GetByID retrieves a snippet by ID
func (r *SnippetRepository) GetByID(ctx context.Context, id string) (*models.Snippet, error) <span class="cov4" title="4">{
        query := `
                SELECT id, title, description, content, language, is_favorite, is_public,
                       view_count, s3_key, checksum, created_at, updated_at
                FROM snippets
                WHERE id = ?
        `

        snippet := &amp;models.Snippet{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;snippet.ID,
                &amp;snippet.Title,
                &amp;snippet.Description,
                &amp;snippet.Content,
                &amp;snippet.Language,
                &amp;snippet.IsFavorite,
                &amp;snippet.IsPublic,
                &amp;snippet.ViewCount,
                &amp;snippet.S3Key,
                &amp;snippet.Checksum,
                &amp;snippet.CreatedAt,
                &amp;snippet.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov2" title="2">{
                return nil, nil
        }</span>
        <span class="cov2" title="2">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get snippet: %w", err)
        }</span>

        <span class="cov2" title="2">return snippet, nil</span>
}

// Update updates an existing snippet
func (r *SnippetRepository) Update(ctx context.Context, id string, input *models.SnippetInput) (*models.Snippet, error) <span class="cov2" title="2">{
        query := `
                UPDATE snippets
                SET title = ?, description = ?, content = ?, language = ?, is_public = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
                RETURNING id, title, description, content, language, is_favorite, is_public,
                          view_count, s3_key, checksum, created_at, updated_at
        `

        snippet := &amp;models.Snippet{}
        err := r.db.QueryRowContext(ctx, query,
                input.Title,
                input.Description,
                input.Content,
                input.Language,
                input.IsPublic,
                id,
        ).Scan(
                &amp;snippet.ID,
                &amp;snippet.Title,
                &amp;snippet.Description,
                &amp;snippet.Content,
                &amp;snippet.Language,
                &amp;snippet.IsFavorite,
                &amp;snippet.IsPublic,
                &amp;snippet.ViewCount,
                &amp;snippet.S3Key,
                &amp;snippet.Checksum,
                &amp;snippet.CreatedAt,
                &amp;snippet.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                return nil, nil
        }</span>
        <span class="cov1" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to update snippet: %w", err)
        }</span>

        <span class="cov1" title="1">return snippet, nil</span>
}

// Delete removes a snippet by ID and cleans up related data
func (r *SnippetRepository) Delete(ctx context.Context, id string) error <span class="cov2" title="2">{
        // Start transaction for atomic delete
        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov2" title="2">defer tx.Rollback()

        // Delete related data first (in case CASCADE doesn't work)
        _, _ = tx.ExecContext(ctx, "DELETE FROM snippet_tags WHERE snippet_id = ?", id)
        _, _ = tx.ExecContext(ctx, "DELETE FROM snippet_folders WHERE snippet_id = ?", id)
        _, _ = tx.ExecContext(ctx, "DELETE FROM snippet_files WHERE snippet_id = ?", id)

        // Delete the snippet
        result, err := tx.ExecContext(ctx, "DELETE FROM snippets WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete snippet: %w", err)
        }</span>

        <span class="cov2" title="2">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov2" title="2">if rows == 0 </span><span class="cov1" title="1">{
                return sql.ErrNoRows
        }</span>

        <span class="cov1" title="1">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// List retrieves snippets with filtering and pagination
func (r *SnippetRepository) List(ctx context.Context, filter models.SnippetFilter) (*models.SnippetListResponse, error) <span class="cov4" title="4">{
        // Build query
        var conditions []string
        var args []interface{}

        // Fuzzy search on title, description, and content
        if filter.Query != "" </span><span class="cov0" title="0">{
                // Split query into words for fuzzy matching
                words := strings.Fields(filter.Query)
                for _, word := range words </span><span class="cov0" title="0">{
                        fuzzyPattern := "%" + word + "%"
                        conditions = append(conditions, "(s.title LIKE ? OR s.description LIKE ? OR s.content LIKE ?)")
                        args = append(args, fuzzyPattern, fuzzyPattern, fuzzyPattern)
                }</span>
        }

        <span class="cov4" title="4">if filter.Language != "" </span><span class="cov1" title="1">{
                conditions = append(conditions, "s.language = ?")
                args = append(args, filter.Language)
        }</span>

        <span class="cov4" title="4">if filter.IsFavorite != nil </span><span class="cov1" title="1">{
                conditions = append(conditions, "s.is_favorite = ?")
                if *filter.IsFavorite </span><span class="cov1" title="1">{
                        args = append(args, 1)
                }</span> else<span class="cov0" title="0"> {
                        args = append(args, 0)
                }</span>
        }

        <span class="cov4" title="4">if filter.IsPublic != nil </span><span class="cov0" title="0">{
                conditions = append(conditions, "s.is_public = ?")
                if *filter.IsPublic </span><span class="cov0" title="0">{
                        args = append(args, 1)
                }</span> else<span class="cov0" title="0"> {
                        args = append(args, 0)
                }</span>
        }

        // Filter by tag
        <span class="cov4" title="4">if filter.TagID &gt; 0 </span><span class="cov0" title="0">{
                conditions = append(conditions, "s.id IN (SELECT snippet_id FROM snippet_tags WHERE tag_id = ?)")
                args = append(args, filter.TagID)
        }</span>

        // Filter by folder
        <span class="cov4" title="4">if filter.FolderID &gt; 0 </span><span class="cov0" title="0">{
                conditions = append(conditions, "s.id IN (SELECT snippet_id FROM snippet_folders WHERE folder_id = ?)")
                args = append(args, filter.FolderID)
        }</span>

        <span class="cov4" title="4">whereClause := ""
        if len(conditions) &gt; 0 </span><span class="cov2" title="2">{
                whereClause = "WHERE " + strings.Join(conditions, " AND ")
        }</span>

        // Count total
        <span class="cov4" title="4">countQuery := fmt.Sprintf("SELECT COUNT(*) FROM snippets s %s", whereClause)
        var total int
        if err := r.db.QueryRowContext(ctx, countQuery, args...).Scan(&amp;total); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to count snippets: %w", err)
        }</span>

        // Validate sort column
        <span class="cov4" title="4">validSortColumns := map[string]bool{
                "created_at": true,
                "updated_at": true,
                "title":      true,
                "language":   true,
        }
        if !validSortColumns[filter.SortBy] </span><span class="cov0" title="0">{
                filter.SortBy = "updated_at"
        }</span>

        <span class="cov4" title="4">sortOrder := "DESC"
        if strings.ToLower(filter.SortOrder) == "asc" </span><span class="cov1" title="1">{
                sortOrder = "ASC"
        }</span>

        // Calculate offset
        <span class="cov4" title="4">offset := (filter.Page - 1) * filter.Limit

        // Build main query
        query := fmt.Sprintf(`
                SELECT s.id, s.title, s.description, s.content, s.language, s.is_favorite, s.is_public,
                       s.view_count, s.s3_key, s.checksum, s.created_at, s.updated_at
                FROM snippets s
                %s
                ORDER BY s.%s %s
                LIMIT ? OFFSET ?
        `, whereClause, filter.SortBy, sortOrder)

        args = append(args, filter.Limit, offset)

        rows, err := r.db.QueryContext(ctx, query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list snippets: %w", err)
        }</span>
        <span class="cov4" title="4">defer rows.Close()

        var snippets []models.Snippet
        for rows.Next() </span><span class="cov6" title="11">{
                var s models.Snippet
                if err := rows.Scan(
                        &amp;s.ID,
                        &amp;s.Title,
                        &amp;s.Description,
                        &amp;s.Content,
                        &amp;s.Language,
                        &amp;s.IsFavorite,
                        &amp;s.IsPublic,
                        &amp;s.ViewCount,
                        &amp;s.S3Key,
                        &amp;s.Checksum,
                        &amp;s.CreatedAt,
                        &amp;s.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan snippet: %w", err)
                }</span>
                <span class="cov6" title="11">snippets = append(snippets, s)</span>
        }

        <span class="cov4" title="4">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating snippets: %w", err)
        }</span>

        // Calculate total pages
        <span class="cov4" title="4">totalPages := total / filter.Limit
        if total%filter.Limit &gt; 0 </span><span class="cov4" title="4">{
                totalPages++
        }</span>

        <span class="cov4" title="4">return &amp;models.SnippetListResponse{
                Data: snippets,
                Pagination: models.Pagination{
                        Page:       filter.Page,
                        Limit:      filter.Limit,
                        Total:      total,
                        TotalPages: totalPages,
                },
        }, nil</span>
}

// ToggleFavorite toggles the favorite status of a snippet
func (r *SnippetRepository) ToggleFavorite(ctx context.Context, id string) (*models.Snippet, error) <span class="cov3" title="3">{
        query := `
                UPDATE snippets
                SET is_favorite = NOT is_favorite
                WHERE id = ?
                RETURNING id, title, description, content, language, is_favorite, is_public,
                          view_count, s3_key, checksum, created_at, updated_at
        `

        snippet := &amp;models.Snippet{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;snippet.ID,
                &amp;snippet.Title,
                &amp;snippet.Description,
                &amp;snippet.Content,
                &amp;snippet.Language,
                &amp;snippet.IsFavorite,
                &amp;snippet.IsPublic,
                &amp;snippet.ViewCount,
                &amp;snippet.S3Key,
                &amp;snippet.Checksum,
                &amp;snippet.CreatedAt,
                &amp;snippet.UpdatedAt,
        )

        if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov3" title="3">if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to toggle favorite: %w", err)
        }</span>

        <span class="cov3" title="3">return snippet, nil</span>
}

// IncrementViewCount increments the view count for a snippet
func (r *SnippetRepository) IncrementViewCount(ctx context.Context, id string) error <span class="cov1" title="1">{
        _, err := r.db.ExecContext(ctx, "UPDATE snippets SET view_count = view_count + 1 WHERE id = ?", id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to increment view count: %w", err)
        }</span>
        <span class="cov1" title="1">return nil</span>
}

// Search performs full-text search on snippets
func (r *SnippetRepository) Search(ctx context.Context, query string, limit int) ([]models.Snippet, error) <span class="cov1" title="1">{
        if limit &lt;= 0 </span><span class="cov0" title="0">{
                limit = 10
        }</span>

        <span class="cov1" title="1">sqlQuery := `
                SELECT s.id, s.title, s.description, s.content, s.language, s.is_favorite, s.is_public,
                       s.view_count, s.s3_key, s.checksum, s.created_at, s.updated_at
                FROM snippets s
                WHERE s.rowid IN (
                        SELECT rowid FROM snippets_fts WHERE snippets_fts MATCH ?
                )
                LIMIT ?
        `

        rows, err := r.db.QueryContext(ctx, sqlQuery, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to search snippets: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var snippets []models.Snippet
        for rows.Next() </span><span class="cov2" title="2">{
                var s models.Snippet
                if err := rows.Scan(
                        &amp;s.ID,
                        &amp;s.Title,
                        &amp;s.Description,
                        &amp;s.Content,
                        &amp;s.Language,
                        &amp;s.IsFavorite,
                        &amp;s.IsPublic,
                        &amp;s.ViewCount,
                        &amp;s.S3Key,
                        &amp;s.Checksum,
                        &amp;s.CreatedAt,
                        &amp;s.UpdatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan snippet: %w", err)
                }</span>
                <span class="cov2" title="2">snippets = append(snippets, s)</span>
        }

        <span class="cov1" title="1">return snippets, rows.Err()</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package repository

import (
        "context"
        "database/sql"
        "fmt"

        "github.com/MohamedElashri/snipo/internal/models"
)

// TagRepository handles tag database operations
type TagRepository struct {
        db *sql.DB
}

// NewTagRepository creates a new tag repository
func NewTagRepository(db *sql.DB) *TagRepository <span class="cov10" title="14">{
        return &amp;TagRepository{db: db}
}</span>

// Create creates a new tag
func (r *TagRepository) Create(ctx context.Context, input *models.TagInput) (*models.Tag, error) <span class="cov9" title="11">{
        query := `
                INSERT INTO tags (name, color)
                VALUES (?, ?)
                RETURNING id, name, color, created_at
        `

        tag := &amp;models.Tag{}
        err := r.db.QueryRowContext(ctx, query, input.Name, input.Color).Scan(
                &amp;tag.ID,
                &amp;tag.Name,
                &amp;tag.Color,
                &amp;tag.CreatedAt,
        )
        if err != nil </span><span class="cov1" title="1">{
                return nil, fmt.Errorf("failed to create tag: %w", err)
        }</span>

        <span class="cov8" title="10">return tag, nil</span>
}

// GetByID retrieves a tag by ID
func (r *TagRepository) GetByID(ctx context.Context, id int64) (*models.Tag, error) <span class="cov4" title="3">{
        query := `SELECT id, name, color, created_at FROM tags WHERE id = ?`

        tag := &amp;models.Tag{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;tag.ID,
                &amp;tag.Name,
                &amp;tag.Color,
                &amp;tag.CreatedAt,
        )
        if err != nil </span><span class="cov3" title="2">{
                if err == sql.ErrNoRows </span><span class="cov3" title="2">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get tag: %w", err)</span>
        }

        <span class="cov1" title="1">return tag, nil</span>
}

// GetByName retrieves a tag by name
func (r *TagRepository) GetByName(ctx context.Context, name string) (*models.Tag, error) <span class="cov3" title="2">{
        query := `SELECT id, name, color, created_at FROM tags WHERE name = ?`

        tag := &amp;models.Tag{}
        err := r.db.QueryRowContext(ctx, query, name).Scan(
                &amp;tag.ID,
                &amp;tag.Name,
                &amp;tag.Color,
                &amp;tag.CreatedAt,
        )
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get tag by name: %w", err)</span>
        }

        <span class="cov1" title="1">return tag, nil</span>
}

// List retrieves all tags with snippet counts
func (r *TagRepository) List(ctx context.Context) ([]models.Tag, error) <span class="cov1" title="1">{
        query := `
                SELECT t.id, t.name, t.color, t.created_at,
                       (SELECT COUNT(*) FROM snippet_tags st 
                        INNER JOIN snippets s ON s.id = st.snippet_id 
                        WHERE st.tag_id = t.id) as snippet_count
                FROM tags t
                ORDER BY t.name ASC
        `

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list tags: %w", err)
        }</span>
        <span class="cov1" title="1">defer rows.Close()

        var tags []models.Tag
        for rows.Next() </span><span class="cov4" title="3">{
                var tag models.Tag
                if err := rows.Scan(&amp;tag.ID, &amp;tag.Name, &amp;tag.Color, &amp;tag.CreatedAt, &amp;tag.SnippetCount); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan tag: %w", err)
                }</span>
                <span class="cov4" title="3">tags = append(tags, tag)</span>
        }

        <span class="cov1" title="1">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating tags: %w", err)
        }</span>

        <span class="cov1" title="1">return tags, nil</span>
}

// Update updates an existing tag
func (r *TagRepository) Update(ctx context.Context, id int64, input *models.TagInput) (*models.Tag, error) <span class="cov3" title="2">{
        query := `
                UPDATE tags
                SET name = ?, color = ?
                WHERE id = ?
                RETURNING id, name, color, created_at
        `

        tag := &amp;models.Tag{}
        err := r.db.QueryRowContext(ctx, query, input.Name, input.Color, id).Scan(
                &amp;tag.ID,
                &amp;tag.Name,
                &amp;tag.Color,
                &amp;tag.CreatedAt,
        )
        if err != nil </span><span class="cov1" title="1">{
                if err == sql.ErrNoRows </span><span class="cov1" title="1">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to update tag: %w", err)</span>
        }

        <span class="cov1" title="1">return tag, nil</span>
}

// Delete deletes a tag
func (r *TagRepository) Delete(ctx context.Context, id int64) error <span class="cov3" title="2">{
        result, err := r.db.ExecContext(ctx, `DELETE FROM tags WHERE id = ?`, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete tag: %w", err)
        }</span>

        <span class="cov3" title="2">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov3" title="2">if rows == 0 </span><span class="cov1" title="1">{
                return ErrNotFound
        }</span>

        <span class="cov1" title="1">return nil</span>
}

// GetSnippetTags retrieves all tags for a snippet
func (r *TagRepository) GetSnippetTags(ctx context.Context, snippetID string) ([]models.Tag, error) <span class="cov3" title="2">{
        query := `
                SELECT t.id, t.name, t.color, t.created_at
                FROM tags t
                JOIN snippet_tags st ON t.id = st.tag_id
                WHERE st.snippet_id = ?
                ORDER BY t.name ASC
        `

        rows, err := r.db.QueryContext(ctx, query, snippetID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get snippet tags: %w", err)
        }</span>
        <span class="cov3" title="2">defer rows.Close()

        var tags []models.Tag
        for rows.Next() </span><span class="cov5" title="4">{
                var tag models.Tag
                if err := rows.Scan(&amp;tag.ID, &amp;tag.Name, &amp;tag.Color, &amp;tag.CreatedAt); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan tag: %w", err)
                }</span>
                <span class="cov5" title="4">tags = append(tags, tag)</span>
        }

        <span class="cov3" title="2">return tags, nil</span>
}

// SetSnippetTags sets the tags for a snippet (replaces existing)
func (r *TagRepository) SetSnippetTags(ctx context.Context, snippetID string, tagNames []string) error <span class="cov7" title="6">{
        tx, err := r.db.BeginTx(ctx, nil)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to begin transaction: %w", err)
        }</span>
        <span class="cov7" title="6">defer tx.Rollback()

        // Remove existing tags
        _, err = tx.ExecContext(ctx, `DELETE FROM snippet_tags WHERE snippet_id = ?`, snippetID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to remove existing tags: %w", err)
        }</span>

        // Add new tags
        <span class="cov7" title="6">for _, name := range tagNames </span><span class="cov8" title="9">{
                // Get or create tag
                var tagID int64
                err := tx.QueryRowContext(ctx, `SELECT id FROM tags WHERE name = ?`, name).Scan(&amp;tagID)
                if err == sql.ErrNoRows </span><span class="cov7" title="6">{
                        // Create new tag with default color
                        err = tx.QueryRowContext(ctx,
                                `INSERT INTO tags (name, color) VALUES (?, '#6366f1') RETURNING id`,
                                name,
                        ).Scan(&amp;tagID)
                        if err != nil </span><span class="cov0" title="0">{
                                return fmt.Errorf("failed to create tag %s: %w", name, err)
                        }</span>
                } else<span class="cov4" title="3"> if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to get tag %s: %w", name, err)
                }</span>

                // Link tag to snippet
                <span class="cov8" title="9">_, err = tx.ExecContext(ctx,
                        `INSERT OR IGNORE INTO snippet_tags (snippet_id, tag_id) VALUES (?, ?)`,
                        snippetID, tagID,
                )
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to link tag %s to snippet: %w", name, err)
                }</span>
        }

        <span class="cov7" title="6">if err := tx.Commit(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to commit transaction: %w", err)
        }</span>

        <span class="cov7" title="6">return nil</span>
}

// GetTagSnippetCount returns the number of snippets for each tag
func (r *TagRepository) GetTagSnippetCount(ctx context.Context, tagID int64) (int, error) <span class="cov1" title="1">{
        var count int
        err := r.db.QueryRowContext(ctx,
                `SELECT COUNT(*) FROM snippet_tags WHERE tag_id = ?`,
                tagID,
        ).Scan(&amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("failed to count snippets for tag: %w", err)
        }</span>
        <span class="cov1" title="1">return count, nil</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">package repository

import (
        "context"
        "crypto/rand"
        "crypto/sha256"
        "database/sql"
        "encoding/hex"
        "fmt"
        "time"

        "github.com/MohamedElashri/snipo/internal/models"
)

// TokenRepository handles API token database operations
type TokenRepository struct {
        db *sql.DB
}

// NewTokenRepository creates a new token repository
func NewTokenRepository(db *sql.DB) *TokenRepository <span class="cov0" title="0">{
        return &amp;TokenRepository{db: db}
}</span>

// generateToken generates a secure random token
func generateToken() (string, error) <span class="cov0" title="0">{
        bytes := make([]byte, 32)
        if _, err := rand.Read(bytes); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(bytes), nil</span>
}

// hashToken creates a SHA256 hash of a token
func hashToken(token string) string <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(token))
        return hex.EncodeToString(hash[:])
}</span>

// Create creates a new API token
func (r *TokenRepository) Create(ctx context.Context, input *models.APITokenInput) (*models.APIToken, error) <span class="cov0" title="0">{
        // Generate token
        token, err := generateToken()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to generate token: %w", err)
        }</span>

        <span class="cov0" title="0">tokenHash := hashToken(token)

        // Validate permissions
        if input.Permissions == "" </span><span class="cov0" title="0">{
                input.Permissions = "read"
        }</span>
        <span class="cov0" title="0">if input.Permissions != "read" &amp;&amp; input.Permissions != "write" &amp;&amp; input.Permissions != "admin" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid permissions: must be 'read', 'write', or 'admin'")
        }</span>

        <span class="cov0" title="0">query := `
                INSERT INTO api_tokens (name, token_hash, permissions, expires_at)
                VALUES (?, ?, ?, ?)
                RETURNING id, name, permissions, last_used_at, expires_at, created_at
        `

        apiToken := &amp;models.APIToken{}
        err = r.db.QueryRowContext(ctx, query, input.Name, tokenHash, input.Permissions, input.ExpiresAt).Scan(
                &amp;apiToken.ID,
                &amp;apiToken.Name,
                &amp;apiToken.Permissions,
                &amp;apiToken.LastUsedAt,
                &amp;apiToken.ExpiresAt,
                &amp;apiToken.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create token: %w", err)
        }</span>

        // Include the plain token in the response (only time it's returned)
        <span class="cov0" title="0">apiToken.Token = token

        return apiToken, nil</span>
}

// GetByID retrieves a token by ID
func (r *TokenRepository) GetByID(ctx context.Context, id int64) (*models.APIToken, error) <span class="cov0" title="0">{
        query := `SELECT id, name, permissions, last_used_at, expires_at, created_at FROM api_tokens WHERE id = ?`

        token := &amp;models.APIToken{}
        err := r.db.QueryRowContext(ctx, query, id).Scan(
                &amp;token.ID,
                &amp;token.Name,
                &amp;token.Permissions,
                &amp;token.LastUsedAt,
                &amp;token.ExpiresAt,
                &amp;token.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get token: %w", err)</span>
        }

        <span class="cov0" title="0">return token, nil</span>
}

// GetByToken retrieves a token by its plain text value (for authentication)
func (r *TokenRepository) GetByToken(ctx context.Context, token string) (*models.APIToken, error) <span class="cov0" title="0">{
        tokenHash := hashToken(token)

        query := `SELECT id, name, permissions, last_used_at, expires_at, created_at FROM api_tokens WHERE token_hash = ?`

        apiToken := &amp;models.APIToken{}
        err := r.db.QueryRowContext(ctx, query, tokenHash).Scan(
                &amp;apiToken.ID,
                &amp;apiToken.Name,
                &amp;apiToken.Permissions,
                &amp;apiToken.LastUsedAt,
                &amp;apiToken.ExpiresAt,
                &amp;apiToken.CreatedAt,
        )
        if err != nil </span><span class="cov0" title="0">{
                if err == sql.ErrNoRows </span><span class="cov0" title="0">{
                        return nil, ErrNotFound
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("failed to get token: %w", err)</span>
        }

        <span class="cov0" title="0">return apiToken, nil</span>
}

// List retrieves all API tokens
func (r *TokenRepository) List(ctx context.Context) ([]models.APIToken, error) <span class="cov0" title="0">{
        query := `SELECT id, name, permissions, last_used_at, expires_at, created_at FROM api_tokens ORDER BY created_at DESC`

        rows, err := r.db.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list tokens: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tokens []models.APIToken
        for rows.Next() </span><span class="cov0" title="0">{
                var token models.APIToken
                if err := rows.Scan(
                        &amp;token.ID,
                        &amp;token.Name,
                        &amp;token.Permissions,
                        &amp;token.LastUsedAt,
                        &amp;token.ExpiresAt,
                        &amp;token.CreatedAt,
                ); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan token: %w", err)
                }</span>
                <span class="cov0" title="0">tokens = append(tokens, token)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating tokens: %w", err)
        }</span>

        <span class="cov0" title="0">return tokens, nil</span>
}

// Delete deletes a token
func (r *TokenRepository) Delete(ctx context.Context, id int64) error <span class="cov0" title="0">{
        result, err := r.db.ExecContext(ctx, `DELETE FROM api_tokens WHERE id = ?`, id)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete token: %w", err)
        }</span>

        <span class="cov0" title="0">rows, err := result.RowsAffected()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get rows affected: %w", err)
        }</span>

        <span class="cov0" title="0">if rows == 0 </span><span class="cov0" title="0">{
                return ErrNotFound
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// UpdateLastUsed updates the last_used_at timestamp for a token
func (r *TokenRepository) UpdateLastUsed(ctx context.Context, id int64) error <span class="cov0" title="0">{
        _, err := r.db.ExecContext(ctx,
                `UPDATE api_tokens SET last_used_at = ? WHERE id = ?`,
                time.Now().UTC(), id,
        )
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to update last used: %w", err)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ValidateToken validates a token and returns it if valid
func (r *TokenRepository) ValidateToken(ctx context.Context, token string) (*models.APIToken, error) <span class="cov0" title="0">{
        apiToken, err := r.GetByToken(ctx, token)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // Check if token is expired
        <span class="cov0" title="0">if apiToken.ExpiresAt != nil &amp;&amp; apiToken.ExpiresAt.Before(time.Now()) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("token expired")
        }</span>

        // Update last used timestamp
        <span class="cov0" title="0">_ = r.UpdateLastUsed(ctx, apiToken.ID)

        return apiToken, nil</span>
}
</pre>
		
		<pre class="file" id="file21" style="display: none">package services

import (
        "archive/zip"
        "bytes"
        "context"
        "crypto/aes"
        "crypto/cipher"
        "crypto/rand"
        "crypto/sha256"
        "database/sql"
        "encoding/json"
        "errors"
        "fmt"
        "log/slog"
        "path/filepath"
        "strings"
        "time"

        "github.com/MohamedElashri/snipo/internal/models"
        "github.com/MohamedElashri/snipo/internal/repository"
)

const (
        BackupVersion = "1.0"
)

var (
        ErrInvalidBackupFormat = errors.New("invalid backup format")
        ErrDecryptionFailed    = errors.New("decryption failed - wrong password?")
)

// BackupService handles backup and restore operations
type BackupService struct {
        db         *sql.DB
        snippetSvc *SnippetService
        tagRepo    *repository.TagRepository
        folderRepo *repository.FolderRepository
        fileRepo   *repository.SnippetFileRepository
        logger     *slog.Logger
}

// NewBackupService creates a new backup service
func NewBackupService(
        db *sql.DB,
        snippetSvc *SnippetService,
        tagRepo *repository.TagRepository,
        folderRepo *repository.FolderRepository,
        fileRepo *repository.SnippetFileRepository,
        logger *slog.Logger,
) *BackupService <span class="cov0" title="0">{
        return &amp;BackupService{
                db:         db,
                snippetSvc: snippetSvc,
                tagRepo:    tagRepo,
                folderRepo: folderRepo,
                fileRepo:   fileRepo,
                logger:     logger,
        }
}</span>

// Export creates a complete backup of all data
func (b *BackupService) Export(ctx context.Context, opts models.ExportOptions) ([]byte, string, error) <span class="cov0" title="0">{
        data := models.BackupData{
                Version:   BackupVersion,
                CreatedAt: time.Now().UTC(),
        }

        // Gather all snippets with their files
        snippetList, err := b.snippetSvc.List(ctx, models.SnippetFilter{
                Page:  1,
                Limit: 10000, // Get all snippets
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", fmt.Errorf("failed to get snippets: %w", err)
        }</span>

        // Fetch full details for each snippet (including files, tags, folders)
        <span class="cov0" title="0">for _, s := range snippetList.Data </span><span class="cov0" title="0">{
                snippet, err := b.snippetSvc.GetByID(ctx, s.ID)
                if err != nil </span><span class="cov0" title="0">{
                        b.logger.Warn("failed to get snippet details", "id", s.ID, "error", err)
                        continue</span>
                }
                <span class="cov0" title="0">data.Snippets = append(data.Snippets, *snippet)</span>
        }

        // Gather all tags
        <span class="cov0" title="0">if b.tagRepo != nil </span><span class="cov0" title="0">{
                tags, err := b.tagRepo.List(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        b.logger.Warn("failed to get tags", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        data.Tags = tags
                }</span>
        }

        // Gather all folders
        <span class="cov0" title="0">if b.folderRepo != nil </span><span class="cov0" title="0">{
                folders, err := b.folderRepo.List(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        b.logger.Warn("failed to get folders", "error", err)
                }</span> else<span class="cov0" title="0"> {
                        data.Folders = folders
                }</span>
        }

        <span class="cov0" title="0">var content []byte
        var filename string

        if opts.Format == "zip" </span><span class="cov0" title="0">{
                content, err = b.createZipBackup(data)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("failed to create zip backup: %w", err)
                }</span>
                <span class="cov0" title="0">filename = fmt.Sprintf("snipo-backup-%s.zip", time.Now().Format("2006-01-02-150405"))</span>
        } else<span class="cov0" title="0"> {
                // Default to JSON
                content, err = json.MarshalIndent(data, "", "  ")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("failed to marshal backup: %w", err)
                }</span>
                <span class="cov0" title="0">filename = fmt.Sprintf("snipo-backup-%s.json", time.Now().Format("2006-01-02-150405"))</span>
        }

        // Encrypt if password provided
        <span class="cov0" title="0">if opts.Password != "" </span><span class="cov0" title="0">{
                content, err = encrypt(content, opts.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, "", fmt.Errorf("failed to encrypt backup: %w", err)
                }</span>
                <span class="cov0" title="0">filename = filename + ".enc"</span>
        }

        <span class="cov0" title="0">b.logger.Info("backup exported",
                "snippets", len(data.Snippets),
                "tags", len(data.Tags),
                "folders", len(data.Folders),
                "format", opts.Format,
                "encrypted", opts.Password != "",
        )

        return content, filename, nil</span>
}

// Import restores data from a backup
func (b *BackupService) Import(ctx context.Context, content []byte, opts models.ImportOptions) (*models.ImportResult, error) <span class="cov0" title="0">{
        // Decrypt if password provided
        var err error
        if opts.Password != "" </span><span class="cov0" title="0">{
                content, err = decrypt(content, opts.Password)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, ErrDecryptionFailed
                }</span>
        }

        <span class="cov0" title="0">var data models.BackupData

        // Try JSON first
        if err := json.Unmarshal(content, &amp;data); err != nil </span><span class="cov0" title="0">{
                // Try ZIP
                zr, zipErr := zip.NewReader(bytes.NewReader(content), int64(len(content)))
                if zipErr != nil </span><span class="cov0" title="0">{
                        return nil, ErrInvalidBackupFormat
                }</span>

                <span class="cov0" title="0">for _, f := range zr.File </span><span class="cov0" title="0">{
                        if f.Name == "metadata.json" </span><span class="cov0" title="0">{
                                rc, err := f.Open()
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("failed to open metadata: %w", err)
                                }</span>
                                <span class="cov0" title="0">if err := json.NewDecoder(rc).Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                                        rc.Close()
                                        return nil, fmt.Errorf("failed to decode metadata: %w", err)
                                }</span>
                                <span class="cov0" title="0">rc.Close()
                                break</span>
                        }
                }

                <span class="cov0" title="0">if data.Version == "" </span><span class="cov0" title="0">{
                        return nil, ErrInvalidBackupFormat
                }</span>
        }

        <span class="cov0" title="0">result := &amp;models.ImportResult{}

        // Handle strategy
        if opts.Strategy == "replace" </span><span class="cov0" title="0">{
                if err := b.clearAllData(ctx); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to clear existing data: %w", err)
                }</span>
        }

        // Build lookup maps for existing data to avoid duplicates
        <span class="cov0" title="0">existingTags, _ := b.tagRepo.List(ctx)
        existingTagsByName := make(map[string]*models.Tag)
        for i := range existingTags </span><span class="cov0" title="0">{
                existingTagsByName[existingTags[i].Name] = &amp;existingTags[i]
        }</span>

        <span class="cov0" title="0">existingFolders, _ := b.folderRepo.List(ctx)
        existingFoldersByName := make(map[string]*models.Folder)
        for i := range existingFolders </span><span class="cov0" title="0">{
                existingFoldersByName[existingFolders[i].Name] = &amp;existingFolders[i]
        }</span>

        <span class="cov0" title="0">existingSnippets, _ := b.snippetSvc.List(ctx, models.SnippetFilter{Limit: 10000})
        existingSnippetsByTitle := make(map[string]*models.Snippet)
        if existingSnippets != nil </span><span class="cov0" title="0">{
                for i := range existingSnippets.Data </span><span class="cov0" title="0">{
                        existingSnippetsByTitle[existingSnippets.Data[i].Title] = &amp;existingSnippets.Data[i]
                }</span>
        }

        // Import tags first (needed for relationships)
        <span class="cov0" title="0">tagMap := make(map[int64]int64) // old ID -&gt; new ID
        for _, tag := range data.Tags </span><span class="cov0" title="0">{
                oldID := tag.ID
                // Check if tag already exists by name
                if existingTag, exists := existingTagsByName[tag.Name]; exists </span><span class="cov0" title="0">{
                        tagMap[oldID] = existingTag.ID
                        // Don't count as imported since it already existed
                }</span> else<span class="cov0" title="0"> {
                        // Create new tag
                        newTag, err := b.tagRepo.Create(ctx, &amp;models.TagInput{
                                Name:  tag.Name,
                                Color: tag.Color,
                        })
                        if err == nil </span><span class="cov0" title="0">{
                                tagMap[oldID] = newTag.ID
                                existingTagsByName[tag.Name] = newTag // Add to map to prevent duplicates
                                result.TagsImported++
                        }</span> else<span class="cov0" title="0"> {
                                result.Errors = append(result.Errors, fmt.Sprintf("tag %s: %v", tag.Name, err))
                        }</span>
                }
        }

        // Import folders
        <span class="cov0" title="0">folderMap := make(map[int64]int64) // old ID -&gt; new ID
        // First pass: create folders without parent relationships (only if they don't exist)
        for _, folder := range data.Folders </span><span class="cov0" title="0">{
                oldID := folder.ID
                // Check if folder already exists by name
                if existingFolder, exists := existingFoldersByName[folder.Name]; exists </span><span class="cov0" title="0">{
                        folderMap[oldID] = existingFolder.ID
                        // Don't count as imported since it already existed
                }</span> else<span class="cov0" title="0"> {
                        input := &amp;models.FolderInput{
                                Name:      folder.Name,
                                Icon:      folder.Icon,
                                SortOrder: folder.SortOrder,
                        }
                        newFolder, err := b.folderRepo.Create(ctx, input)
                        if err == nil </span><span class="cov0" title="0">{
                                folderMap[oldID] = newFolder.ID
                                existingFoldersByName[folder.Name] = newFolder // Add to map to prevent duplicates
                                result.FoldersImported++
                        }</span> else<span class="cov0" title="0"> {
                                result.Errors = append(result.Errors, fmt.Sprintf("folder %s: %v", folder.Name, err))
                        }</span>
                }
        }

        // Second pass: update parent relationships for newly created folders
        <span class="cov0" title="0">for _, folder := range data.Folders </span><span class="cov0" title="0">{
                if folder.ParentID != nil </span><span class="cov0" title="0">{
                        // Only update if this folder was newly created
                        if _, existed := existingFoldersByName[folder.Name]; !existed </span><span class="cov0" title="0">{
                                if newID, ok := folderMap[folder.ID]; ok </span><span class="cov0" title="0">{
                                        if newParentID, ok := folderMap[*folder.ParentID]; ok </span><span class="cov0" title="0">{
                                                b.folderRepo.Move(ctx, newID, &amp;newParentID)
                                        }</span>
                                }
                        }
                }
        }

        // Import snippets
        <span class="cov0" title="0">for _, snippet := range data.Snippets </span><span class="cov0" title="0">{
                // Check if snippet with same title already exists
                if _, exists := existingSnippetsByTitle[snippet.Title]; exists </span><span class="cov0" title="0">{
                        // Skip if strategy is "skip" or "merge" (merge doesn't overwrite existing)
                        if opts.Strategy == "skip" || opts.Strategy == "merge" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                // Prepare input
                <span class="cov0" title="0">input := &amp;models.SnippetInput{
                        Title:       snippet.Title,
                        Description: snippet.Description,
                        Content:     snippet.Content,
                        Language:    snippet.Language,
                        IsPublic:    snippet.IsPublic,
                }

                // Map tags
                for _, tag := range snippet.Tags </span><span class="cov0" title="0">{
                        input.Tags = append(input.Tags, tag.Name)
                }</span>

                // Map folder (use first folder if any)
                <span class="cov0" title="0">if len(snippet.Folders) &gt; 0 </span><span class="cov0" title="0">{
                        if newFolderID, ok := folderMap[snippet.Folders[0].ID]; ok </span><span class="cov0" title="0">{
                                input.FolderID = &amp;newFolderID
                        }</span>
                }

                // Map files
                <span class="cov0" title="0">for _, file := range snippet.Files </span><span class="cov0" title="0">{
                        input.Files = append(input.Files, models.SnippetFileInput{
                                Filename: file.Filename,
                                Content:  file.Content,
                                Language: file.Language,
                        })
                }</span>

                <span class="cov0" title="0">_, err := b.snippetSvc.Create(ctx, input)
                if err == nil </span><span class="cov0" title="0">{
                        result.SnippetsImported++
                        // Add to map to prevent duplicates within same import
                        existingSnippetsByTitle[snippet.Title] = &amp;snippet
                }</span> else<span class="cov0" title="0"> {
                        result.Errors = append(result.Errors, fmt.Sprintf("snippet %s: %v", snippet.Title, err))
                }</span>
        }

        <span class="cov0" title="0">b.logger.Info("backup imported",
                "snippets", result.SnippetsImported,
                "tags", result.TagsImported,
                "folders", result.FoldersImported,
                "errors", len(result.Errors),
        )

        return result, nil</span>
}

// createZipBackup creates a ZIP archive with snippets as individual files
func (b *BackupService) createZipBackup(data models.BackupData) ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        zw := zip.NewWriter(buf)

        // Add snippets as individual files
        for _, s := range data.Snippets </span><span class="cov0" title="0">{
                // Add each file in the snippet
                if len(s.Files) &gt; 0 </span><span class="cov0" title="0">{
                        for _, f := range s.Files </span><span class="cov0" title="0">{
                                filename := fmt.Sprintf("snippets/%s/%s", sanitizeFilename(s.Title), f.Filename)
                                w, err := zw.Create(filename)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov0" title="0">w.Write([]byte(f.Content))</span>
                        }
                } else<span class="cov0" title="0"> {
                        // Legacy single-file snippet
                        ext := getExtension(s.Language)
                        filename := fmt.Sprintf("snippets/%s.%s", sanitizeFilename(s.Title), ext)
                        w, err := zw.Create(filename)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">w.Write([]byte(s.Content))</span>
                }
        }

        // Add metadata
        <span class="cov0" title="0">metaW, err := zw.Create("metadata.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if err := json.NewEncoder(metaW).Encode(data); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := zw.Close(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return buf.Bytes(), nil</span>
}

// clearAllData removes all snippets, tags, and folders
func (b *BackupService) clearAllData(ctx context.Context) error <span class="cov0" title="0">{
        queries := []string{
                "DELETE FROM snippet_tags",
                "DELETE FROM snippet_folders",
                "DELETE FROM snippet_files",
                "DELETE FROM snippets",
                "DELETE FROM tags",
                "DELETE FROM folders",
        }

        for _, q := range queries </span><span class="cov0" title="0">{
                if _, err := b.db.ExecContext(ctx, q); err != nil </span><span class="cov0" title="0">{
                        b.logger.Warn("failed to execute clear query", "query", q, "error", err)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// sanitizeFilename removes invalid characters from filename
func sanitizeFilename(name string) string <span class="cov0" title="0">{
        // Replace invalid characters
        invalid := []string{"/", "\\", ":", "*", "?", "\"", "&lt;", "&gt;", "|"}
        result := name
        for _, c := range invalid </span><span class="cov0" title="0">{
                result = strings.ReplaceAll(result, c, "_")
        }</span>
        // Limit length
        <span class="cov0" title="0">if len(result) &gt; 50 </span><span class="cov0" title="0">{
                result = result[:50]
        }</span>
        <span class="cov0" title="0">return result</span>
}

// getExtension returns file extension for a language
func getExtension(lang string) string <span class="cov0" title="0">{
        extensions := map[string]string{
                "javascript": "js",
                "typescript": "ts",
                "python":     "py",
                "go":         "go",
                "rust":       "rs",
                "java":       "java",
                "c":          "c",
                "cpp":        "cpp",
                "csharp":     "cs",
                "php":        "php",
                "ruby":       "rb",
                "swift":      "swift",
                "kotlin":     "kt",
                "scala":      "scala",
                "html":       "html",
                "css":        "css",
                "scss":       "scss",
                "json":       "json",
                "yaml":       "yaml",
                "xml":        "xml",
                "markdown":   "md",
                "sql":        "sql",
                "bash":       "sh",
                "shell":      "sh",
                "powershell": "ps1",
                "dockerfile": "dockerfile",
                "nginx":      "conf",
                "toml":       "toml",
                "ini":        "ini",
                "makefile":   "mk",
        }

        if ext, ok := extensions[lang]; ok </span><span class="cov0" title="0">{
                return ext
        }</span>
        <span class="cov0" title="0">return "txt"</span>
}

// deriveKey derives a 32-byte key from password using SHA256
func deriveKey(password string) []byte <span class="cov0" title="0">{
        hash := sha256.Sum256([]byte(password))
        return hash[:]
}</span>

// encrypt encrypts data using AES-256-GCM
func encrypt(data []byte, password string) ([]byte, error) <span class="cov0" title="0">{
        key := deriveKey(password)

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nonce := make([]byte, gcm.NonceSize())
        if _, err := rand.Read(nonce); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return gcm.Seal(nonce, nonce, data, nil), nil</span>
}

// decrypt decrypts data using AES-256-GCM
func decrypt(data []byte, password string) ([]byte, error) <span class="cov0" title="0">{
        key := deriveKey(password)

        block, err := aes.NewCipher(key)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">gcm, err := cipher.NewGCM(block)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">nonceSize := gcm.NonceSize()
        if len(data) &lt; nonceSize </span><span class="cov0" title="0">{
                return nil, errors.New("ciphertext too short")
        }</span>

        <span class="cov0" title="0">nonce, ciphertext := data[:nonceSize], data[nonceSize:]
        return gcm.Open(nil, nonce, ciphertext, nil)</span>
}

// GetFilename generates a backup filename
func GetBackupFilename(format string, encrypted bool) string <span class="cov0" title="0">{
        timestamp := time.Now().Format("2006-01-02-150405")
        ext := "json"
        if format == "zip" </span><span class="cov0" title="0">{
                ext = "zip"
        }</span>
        <span class="cov0" title="0">filename := fmt.Sprintf("snipo-backup-%s.%s", timestamp, ext)
        if encrypted </span><span class="cov0" title="0">{
                filename += ".enc"
        }</span>
        <span class="cov0" title="0">return filename</span>
}

// ValidateBackupFile checks if the content looks like a valid backup
func ValidateBackupFile(content []byte) (string, error) <span class="cov0" title="0">{
        // Check for JSON
        var data models.BackupData
        if err := json.Unmarshal(content, &amp;data); err == nil </span><span class="cov0" title="0">{
                if data.Version != "" </span><span class="cov0" title="0">{
                        return "json", nil
                }</span>
        }

        // Check for ZIP
        <span class="cov0" title="0">if len(content) &gt; 4 &amp;&amp; content[0] == 'P' &amp;&amp; content[1] == 'K' </span><span class="cov0" title="0">{
                return "zip", nil
        }</span>

        // Check for encrypted (starts with random bytes, so just check it's not empty)
        <span class="cov0" title="0">if len(content) &gt; 32 </span><span class="cov0" title="0">{
                return "encrypted", nil
        }</span>

        <span class="cov0" title="0">return "", ErrInvalidBackupFormat</span>
}

// Unused but kept for reference
var _ = filepath.Base
</pre>
		
		<pre class="file" id="file22" style="display: none">package services

import (
        "context"
        "fmt"
        "log/slog"
        "strings"
        "time"

        "github.com/MohamedElashri/snipo/internal/models"
        "github.com/MohamedElashri/snipo/internal/storage"
)

// S3SyncService handles S3 backup operations
type S3SyncService struct {
        storage   *storage.S3Storage
        backupSvc *BackupService
        logger    *slog.Logger
}

// NewS3SyncService creates a new S3 sync service
func NewS3SyncService(storage *storage.S3Storage, backupSvc *BackupService, logger *slog.Logger) *S3SyncService <span class="cov0" title="0">{
        return &amp;S3SyncService{
                storage:   storage,
                backupSvc: backupSvc,
                logger:    logger,
        }
}</span>

// SyncToS3 uploads a backup to S3
func (s *S3SyncService) SyncToS3(ctx context.Context, opts models.ExportOptions) (*models.S3SyncResult, error) <span class="cov0" title="0">{
        result := &amp;models.S3SyncResult{
                StartedAt: time.Now().UTC(),
        }

        // Create backup
        content, filename, err := s.backupSvc.Export(ctx, opts)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create backup: %w", err)
        }</span>

        // Determine content type
        <span class="cov0" title="0">contentType := "application/json"
        if strings.HasSuffix(filename, ".zip") || strings.HasSuffix(filename, ".zip.enc") </span><span class="cov0" title="0">{
                contentType = "application/zip"
        }</span>
        <span class="cov0" title="0">if strings.HasSuffix(filename, ".enc") </span><span class="cov0" title="0">{
                contentType = "application/octet-stream"
        }</span>

        // Upload to S3
        <span class="cov0" title="0">key := "backups/" + filename
        if err := s.storage.Upload(ctx, key, content, contentType); err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Sprintf("failed to upload: %v", err))
                result.FinishedAt = time.Now().UTC()
                return result, fmt.Errorf("failed to upload backup: %w", err)
        }</span>

        <span class="cov0" title="0">result.Uploaded = 1
        result.FinishedAt = time.Now().UTC()

        s.logger.Info("backup synced to S3",
                "key", key,
                "size", len(content),
                "duration", result.FinishedAt.Sub(result.StartedAt),
        )

        return result, nil</span>
}

// ListBackups returns all backups stored in S3
func (s *S3SyncService) ListBackups(ctx context.Context) ([]models.S3BackupInfo, error) <span class="cov0" title="0">{
        objects, err := s.storage.List(ctx, "backups/")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to list backups: %w", err)
        }</span>

        <span class="cov0" title="0">var backups []models.S3BackupInfo
        for _, obj := range objects </span><span class="cov0" title="0">{
                backups = append(backups, models.S3BackupInfo{
                        Key:          obj.Key,
                        Size:         obj.Size,
                        LastModified: obj.LastModified,
                })
        }</span>

        <span class="cov0" title="0">return backups, nil</span>
}

// RestoreFromS3 downloads and restores a backup from S3
func (s *S3SyncService) RestoreFromS3(ctx context.Context, key string, opts models.ImportOptions) (*models.S3RestoreResult, error) <span class="cov0" title="0">{
        result := &amp;models.S3RestoreResult{
                StartedAt: time.Now().UTC(),
        }

        // Download backup from S3
        content, err := s.storage.Download(ctx, key)
        if err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Sprintf("failed to download: %v", err))
                result.FinishedAt = time.Now().UTC()
                return result, fmt.Errorf("failed to download backup: %w", err)
        }</span>

        // Import backup
        <span class="cov0" title="0">importResult, err := s.backupSvc.Import(ctx, content, opts)
        if err != nil </span><span class="cov0" title="0">{
                result.Errors = append(result.Errors, fmt.Sprintf("failed to import: %v", err))
                result.FinishedAt = time.Now().UTC()
                return result, fmt.Errorf("failed to import backup: %w", err)
        }</span>

        <span class="cov0" title="0">result.Restored = importResult.SnippetsImported + importResult.TagsImported + importResult.FoldersImported
        result.Errors = append(result.Errors, importResult.Errors...)
        result.FinishedAt = time.Now().UTC()

        s.logger.Info("backup restored from S3",
                "key", key,
                "snippets", importResult.SnippetsImported,
                "tags", importResult.TagsImported,
                "folders", importResult.FoldersImported,
                "duration", result.FinishedAt.Sub(result.StartedAt),
        )

        return result, nil</span>
}

// DeleteBackup removes a backup from S3
func (s *S3SyncService) DeleteBackup(ctx context.Context, key string) error <span class="cov0" title="0">{
        if err := s.storage.Delete(ctx, key); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to delete backup: %w", err)
        }</span>

        <span class="cov0" title="0">s.logger.Info("backup deleted from S3", "key", key)
        return nil</span>
}

// GetBackupURL generates a presigned URL for downloading a backup
func (s *S3SyncService) GetBackupURL(ctx context.Context, key string, expiry time.Duration) (string, error) <span class="cov0" title="0">{
        url, err := s.storage.GetPresignedURL(ctx, key, expiry)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("failed to generate presigned URL: %w", err)
        }</span>
        <span class="cov0" title="0">return url, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">package services

import (
        "context"
        "database/sql"
        "errors"
        "log/slog"

        "github.com/MohamedElashri/snipo/internal/models"
        "github.com/MohamedElashri/snipo/internal/repository"
        "github.com/MohamedElashri/snipo/internal/validation"
)

// Common errors
var (
        ErrSnippetNotFound = errors.New("snippet not found")
        ErrValidation      = errors.New("validation error")
)

// SnippetService handles snippet business logic
type SnippetService struct {
        repo               *repository.SnippetRepository
        tagRepo            *repository.TagRepository
        folderRepo         *repository.FolderRepository
        fileRepo           *repository.SnippetFileRepository
        logger             *slog.Logger
        maxFilesPerSnippet int
}

// NewSnippetService creates a new snippet service
func NewSnippetService(repo *repository.SnippetRepository, logger *slog.Logger) *SnippetService <span class="cov0" title="0">{
        return &amp;SnippetService{
                repo:               repo,
                logger:             logger,
                maxFilesPerSnippet: 10, // Default
        }
}</span>

// WithTagRepo adds tag repository to the service
func (s *SnippetService) WithTagRepo(tagRepo *repository.TagRepository) *SnippetService <span class="cov0" title="0">{
        s.tagRepo = tagRepo
        return s
}</span>

// WithFolderRepo adds folder repository to the service
func (s *SnippetService) WithFolderRepo(folderRepo *repository.FolderRepository) *SnippetService <span class="cov0" title="0">{
        s.folderRepo = folderRepo
        return s
}</span>

// WithFileRepo adds file repository to the service
func (s *SnippetService) WithFileRepo(fileRepo *repository.SnippetFileRepository) *SnippetService <span class="cov0" title="0">{
        s.fileRepo = fileRepo
        return s
}</span>

// WithMaxFiles sets the maximum files per snippet
func (s *SnippetService) WithMaxFiles(max int) *SnippetService <span class="cov0" title="0">{
        s.maxFilesPerSnippet = max
        return s
}</span>

// Create creates a new snippet
func (s *SnippetService) Create(ctx context.Context, input *models.SnippetInput) (*models.Snippet, error) <span class="cov0" title="0">{
        // Validate input
        if errs := validation.ValidateSnippetInput(input); errs.HasErrors() </span><span class="cov0" title="0">{
                return nil, errs
        }</span>

        <span class="cov0" title="0">snippet, err := s.repo.Create(ctx, input)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to create snippet", "error", err)
                return nil, err
        }</span>

        // Set tags if provided
        <span class="cov0" title="0">if s.tagRepo != nil &amp;&amp; len(input.Tags) &gt; 0 </span><span class="cov0" title="0">{
                if err := s.tagRepo.SetSnippetTags(ctx, snippet.ID, input.Tags); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("failed to set snippet tags", "id", snippet.ID, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        // Fetch tags to include in response
                        tags, _ := s.tagRepo.GetSnippetTags(ctx, snippet.ID)
                        snippet.Tags = tags
                }</span>
        }

        // Set folder if provided
        <span class="cov0" title="0">if s.folderRepo != nil &amp;&amp; input.FolderID != nil </span><span class="cov0" title="0">{
                if err := s.folderRepo.SetSnippetFolder(ctx, snippet.ID, input.FolderID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("failed to set snippet folder", "id", snippet.ID, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        // Fetch folders to include in response
                        folders, _ := s.folderRepo.GetSnippetFolders(ctx, snippet.ID)
                        snippet.Folders = folders
                }</span>
        }

        // Create files if provided
        <span class="cov0" title="0">if s.fileRepo != nil &amp;&amp; len(input.Files) &gt; 0 </span><span class="cov0" title="0">{
                // Limit files
                files := input.Files
                if len(files) &gt; s.maxFilesPerSnippet </span><span class="cov0" title="0">{
                        files = files[:s.maxFilesPerSnippet]
                }</span>
                <span class="cov0" title="0">createdFiles, err := s.fileRepo.SyncFiles(ctx, snippet.ID, files)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("failed to create snippet files", "id", snippet.ID, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        snippet.Files = createdFiles
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("snippet created", "id", snippet.ID, "title", snippet.Title)
        return snippet, nil</span>
}

// GetByID retrieves a snippet by ID
func (s *SnippetService) GetByID(ctx context.Context, id string) (*models.Snippet, error) <span class="cov0" title="0">{
        snippet, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to get snippet", "id", id, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if snippet == nil </span><span class="cov0" title="0">{
                return nil, ErrSnippetNotFound
        }</span>

        // Fetch tags
        <span class="cov0" title="0">if s.tagRepo != nil </span><span class="cov0" title="0">{
                tags, _ := s.tagRepo.GetSnippetTags(ctx, id)
                snippet.Tags = tags
        }</span>

        // Fetch folders
        <span class="cov0" title="0">if s.folderRepo != nil </span><span class="cov0" title="0">{
                folders, _ := s.folderRepo.GetSnippetFolders(ctx, id)
                snippet.Folders = folders
        }</span>

        // Fetch files
        <span class="cov0" title="0">if s.fileRepo != nil </span><span class="cov0" title="0">{
                files, _ := s.fileRepo.GetBySnippetID(ctx, id)
                snippet.Files = files
        }</span>

        <span class="cov0" title="0">return snippet, nil</span>
}

// GetByIDPublic retrieves a public snippet by ID and increments view count
func (s *SnippetService) GetByIDPublic(ctx context.Context, id string) (*models.Snippet, error) <span class="cov0" title="0">{
        snippet, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if snippet == nil || !snippet.IsPublic </span><span class="cov0" title="0">{
                return nil, ErrSnippetNotFound
        }</span>

        // Increment view count asynchronously
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                if err := s.repo.IncrementViewCount(context.Background(), id); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("failed to increment view count", "id", id, "error", err)
                }</span>
        }()

        // Fetch files for public view
        <span class="cov0" title="0">if s.fileRepo != nil </span><span class="cov0" title="0">{
                files, _ := s.fileRepo.GetBySnippetID(ctx, id)
                snippet.Files = files
        }</span>

        <span class="cov0" title="0">return snippet, nil</span>
}

// Update updates an existing snippet
func (s *SnippetService) Update(ctx context.Context, id string, input *models.SnippetInput) (*models.Snippet, error) <span class="cov0" title="0">{
        // Validate input
        if errs := validation.ValidateSnippetInput(input); errs.HasErrors() </span><span class="cov0" title="0">{
                return nil, errs
        }</span>

        // Check if snippet exists
        <span class="cov0" title="0">existing, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if existing == nil </span><span class="cov0" title="0">{
                return nil, ErrSnippetNotFound
        }</span>

        <span class="cov0" title="0">snippet, err := s.repo.Update(ctx, id, input)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to update snippet", "id", id, "error", err)
                return nil, err
        }</span>

        // Update tags if provided
        <span class="cov0" title="0">if s.tagRepo != nil &amp;&amp; input.Tags != nil </span><span class="cov0" title="0">{
                if err := s.tagRepo.SetSnippetTags(ctx, id, input.Tags); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("failed to update snippet tags", "id", id, "error", err)
                }</span>
                <span class="cov0" title="0">tags, _ := s.tagRepo.GetSnippetTags(ctx, id)
                snippet.Tags = tags</span>
        }

        // Update folder if provided
        <span class="cov0" title="0">if s.folderRepo != nil </span><span class="cov0" title="0">{
                if err := s.folderRepo.SetSnippetFolder(ctx, id, input.FolderID); err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("failed to update snippet folder", "id", id, "error", err)
                }</span>
                <span class="cov0" title="0">folders, _ := s.folderRepo.GetSnippetFolders(ctx, id)
                snippet.Folders = folders</span>
        }

        // Update files if provided
        <span class="cov0" title="0">if s.fileRepo != nil &amp;&amp; input.Files != nil </span><span class="cov0" title="0">{
                // Limit files
                files := input.Files
                if len(files) &gt; s.maxFilesPerSnippet </span><span class="cov0" title="0">{
                        files = files[:s.maxFilesPerSnippet]
                }</span>
                <span class="cov0" title="0">syncedFiles, err := s.fileRepo.SyncFiles(ctx, id, files)
                if err != nil </span><span class="cov0" title="0">{
                        s.logger.Warn("failed to update snippet files", "id", id, "error", err)
                }</span> else<span class="cov0" title="0"> {
                        snippet.Files = syncedFiles
                }</span>
        }

        <span class="cov0" title="0">s.logger.Info("snippet updated", "id", id)
        return snippet, nil</span>
}

// Delete removes a snippet
func (s *SnippetService) Delete(ctx context.Context, id string) error <span class="cov0" title="0">{
        err := s.repo.Delete(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                if errors.Is(err, sql.ErrNoRows) </span><span class="cov0" title="0">{
                        return ErrSnippetNotFound
                }</span>
                <span class="cov0" title="0">s.logger.Error("failed to delete snippet", "id", id, "error", err)
                return err</span>
        }

        <span class="cov0" title="0">s.logger.Info("snippet deleted", "id", id)
        return nil</span>
}

// List retrieves snippets with filtering and pagination
func (s *SnippetService) List(ctx context.Context, filter models.SnippetFilter) (*models.SnippetListResponse, error) <span class="cov0" title="0">{
        // Apply defaults
        if filter.Page &lt;= 0 </span><span class="cov0" title="0">{
                filter.Page = 1
        }</span>
        <span class="cov0" title="0">if filter.Limit &lt;= 0 </span><span class="cov0" title="0">{
                filter.Limit = 20
        }</span>
        <span class="cov0" title="0">if filter.Limit &gt; 100 </span><span class="cov0" title="0">{
                filter.Limit = 100
        }</span>
        <span class="cov0" title="0">if filter.SortBy == "" </span><span class="cov0" title="0">{
                filter.SortBy = "updated_at"
        }</span>
        <span class="cov0" title="0">if filter.SortOrder == "" </span><span class="cov0" title="0">{
                filter.SortOrder = "desc"
        }</span>

        <span class="cov0" title="0">return s.repo.List(ctx, filter)</span>
}

// ToggleFavorite toggles the favorite status of a snippet
func (s *SnippetService) ToggleFavorite(ctx context.Context, id string) (*models.Snippet, error) <span class="cov0" title="0">{
        snippet, err := s.repo.ToggleFavorite(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to toggle favorite", "id", id, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">if snippet == nil </span><span class="cov0" title="0">{
                return nil, ErrSnippetNotFound
        }</span>

        <span class="cov0" title="0">s.logger.Info("snippet favorite toggled", "id", id, "is_favorite", snippet.IsFavorite)
        return snippet, nil</span>
}

// Search performs full-text search on snippets
func (s *SnippetService) Search(ctx context.Context, query string, limit int) ([]models.Snippet, error) <span class="cov0" title="0">{
        if query == "" </span><span class="cov0" title="0">{
                return []models.Snippet{}, nil
        }</span>

        <span class="cov0" title="0">snippets, err := s.repo.Search(ctx, query, limit)
        if err != nil </span><span class="cov0" title="0">{
                s.logger.Error("failed to search snippets", "query", query, "error", err)
                return nil, err
        }</span>

        <span class="cov0" title="0">return snippets, nil</span>
}

// Duplicate creates a copy of an existing snippet
func (s *SnippetService) Duplicate(ctx context.Context, id string) (*models.Snippet, error) <span class="cov0" title="0">{
        existing, err := s.repo.GetByID(ctx, id)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if existing == nil </span><span class="cov0" title="0">{
                return nil, ErrSnippetNotFound
        }</span>

        <span class="cov0" title="0">input := &amp;models.SnippetInput{
                Title:       existing.Title + " (copy)",
                Description: existing.Description,
                Content:     existing.Content,
                Language:    existing.Language,
                IsPublic:    false, // Copies are private by default
        }

        return s.repo.Create(ctx, input)</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">package storage

import (
        "bytes"
        "context"
        "errors"
        "fmt"
        "io"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/config"
        "github.com/aws/aws-sdk-go-v2/credentials"
        "github.com/aws/aws-sdk-go-v2/service/s3"
        "github.com/aws/aws-sdk-go-v2/service/s3/types"
)

// S3Config holds S3 storage configuration
type S3Config struct {
        Endpoint        string
        AccessKeyID     string
        SecretAccessKey string
        Bucket          string
        Region          string
        UseSSL          bool
}

// S3Storage provides S3-compatible object storage operations
type S3Storage struct {
        client *s3.Client
        bucket string
}

// ObjectInfo represents information about an S3 object
type ObjectInfo struct {
        Key          string
        Size         int64
        LastModified time.Time
}

// NewS3Storage creates a new S3 storage client
func NewS3Storage(cfg S3Config) (*S3Storage, error) <span class="cov0" title="0">{
        // Build endpoint URL
        scheme := "https"
        if !cfg.UseSSL </span><span class="cov0" title="0">{
                scheme = "http"
        }</span>
        <span class="cov0" title="0">endpointURL := fmt.Sprintf("%s://%s", scheme, cfg.Endpoint)

        // Create custom resolver for S3-compatible endpoints
        customResolver := aws.EndpointResolverWithOptionsFunc(func(service, region string, options ...interface{}) (aws.Endpoint, error) </span><span class="cov0" title="0">{
                if service == s3.ServiceID </span><span class="cov0" title="0">{
                        return aws.Endpoint{
                                URL:               endpointURL,
                                HostnameImmutable: true,
                                SigningRegion:     cfg.Region,
                        }, nil
                }</span>
                <span class="cov0" title="0">return aws.Endpoint{}, fmt.Errorf("unknown endpoint requested")</span>
        })

        // Load AWS config
        <span class="cov0" title="0">awsCfg, err := config.LoadDefaultConfig(context.Background(),
                config.WithRegion(cfg.Region),
                config.WithCredentialsProvider(credentials.NewStaticCredentialsProvider(
                        cfg.AccessKeyID,
                        cfg.SecretAccessKey,
                        "",
                )),
                config.WithEndpointResolverWithOptions(customResolver),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to load AWS config: %w", err)
        }</span>

        // Create S3 client with path-style addressing for S3-compatible services
        <span class="cov0" title="0">client := s3.NewFromConfig(awsCfg, func(o *s3.Options) </span><span class="cov0" title="0">{
                o.UsePathStyle = true
        }</span>)

        // Ensure bucket exists
        <span class="cov0" title="0">ctx := context.Background()
        _, err = client.HeadBucket(ctx, &amp;s3.HeadBucketInput{
                Bucket: aws.String(cfg.Bucket),
        })
        if err != nil </span><span class="cov0" title="0">{
                // Try to create the bucket if it doesn't exist
                var notFound *types.NotFound
                if errors.As(err, &amp;notFound) </span><span class="cov0" title="0">{
                        _, createErr := client.CreateBucket(ctx, &amp;s3.CreateBucketInput{
                                Bucket: aws.String(cfg.Bucket),
                        })
                        if createErr != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("failed to create bucket: %w", createErr)
                        }</span>
                } else<span class="cov0" title="0"> {
                        return nil, fmt.Errorf("failed to check bucket: %w", err)
                }</span>
        }

        <span class="cov0" title="0">return &amp;S3Storage{client: client, bucket: cfg.Bucket}, nil</span>
}

// Upload uploads content to S3
func (s *S3Storage) Upload(ctx context.Context, key string, content []byte, contentType string) error <span class="cov0" title="0">{
        _, err := s.client.PutObject(ctx, &amp;s3.PutObjectInput{
                Bucket:      aws.String(s.bucket),
                Key:         aws.String(key),
                Body:        bytes.NewReader(content),
                ContentType: aws.String(contentType),
        })
        return err
}</span>

// UploadReader uploads content from a reader to S3
func (s *S3Storage) UploadReader(ctx context.Context, key string, reader io.Reader, size int64, contentType string) error <span class="cov0" title="0">{
        _, err := s.client.PutObject(ctx, &amp;s3.PutObjectInput{
                Bucket:        aws.String(s.bucket),
                Key:           aws.String(key),
                Body:          reader,
                ContentLength: aws.Int64(size),
                ContentType:   aws.String(contentType),
        })
        return err
}</span>

// Download retrieves content from S3
func (s *S3Storage) Download(ctx context.Context, key string) ([]byte, error) <span class="cov0" title="0">{
        result, err := s.client.GetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(s.bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get object: %w", err)
        }</span>
        <span class="cov0" title="0">defer result.Body.Close()

        content, err := io.ReadAll(result.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read object: %w", err)
        }</span>

        <span class="cov0" title="0">return content, nil</span>
}

// Delete removes an object from S3
func (s *S3Storage) Delete(ctx context.Context, key string) error <span class="cov0" title="0">{
        _, err := s.client.DeleteObject(ctx, &amp;s3.DeleteObjectInput{
                Bucket: aws.String(s.bucket),
                Key:    aws.String(key),
        })
        return err
}</span>

// List returns objects with given prefix
func (s *S3Storage) List(ctx context.Context, prefix string) ([]ObjectInfo, error) <span class="cov0" title="0">{
        var objects []ObjectInfo

        paginator := s3.NewListObjectsV2Paginator(s.client, &amp;s3.ListObjectsV2Input{
                Bucket: aws.String(s.bucket),
                Prefix: aws.String(prefix),
        })

        for paginator.HasMorePages() </span><span class="cov0" title="0">{
                page, err := paginator.NextPage(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to list objects: %w", err)
                }</span>

                <span class="cov0" title="0">for _, obj := range page.Contents </span><span class="cov0" title="0">{
                        objects = append(objects, ObjectInfo{
                                Key:          aws.ToString(obj.Key),
                                Size:         aws.ToInt64(obj.Size),
                                LastModified: aws.ToTime(obj.LastModified),
                        })
                }</span>
        }

        <span class="cov0" title="0">return objects, nil</span>
}

// GetPresignedURL generates a temporary download URL
func (s *S3Storage) GetPresignedURL(ctx context.Context, key string, expiry time.Duration) (string, error) <span class="cov0" title="0">{
        presignClient := s3.NewPresignClient(s.client)
        request, err := presignClient.PresignGetObject(ctx, &amp;s3.GetObjectInput{
                Bucket: aws.String(s.bucket),
                Key:    aws.String(key),
        }, s3.WithPresignExpires(expiry))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">return request.URL, nil</span>
}

// Exists checks if an object exists
func (s *S3Storage) Exists(ctx context.Context, key string) (bool, error) <span class="cov0" title="0">{
        _, err := s.client.HeadObject(ctx, &amp;s3.HeadObjectInput{
                Bucket: aws.String(s.bucket),
                Key:    aws.String(key),
        })
        if err != nil </span><span class="cov0" title="0">{
                var notFound *types.NotFound
                if errors.As(err, &amp;notFound) </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
                <span class="cov0" title="0">return false, err</span>
        }
        <span class="cov0" title="0">return true, nil</span>
}

// GetBucket returns the bucket name
func (s *S3Storage) GetBucket() string <span class="cov0" title="0">{
        return s.bucket
}</span>
</pre>
		
		<pre class="file" id="file25" style="display: none">// Package testutil provides testing utilities for the snipo application.
package testutil

import (
        "context"
        "database/sql"
        "log/slog"
        "os"
        "testing"

        _ "modernc.org/sqlite"
)

// TestDB creates an in-memory SQLite database for testing.
// It runs migrations and returns the database connection.
// The database is automatically closed when the test completes.
func TestDB(t *testing.T) *sql.DB <span class="cov0" title="0">{
        t.Helper()

        db, err := sql.Open("sqlite", ":memory:?_foreign_keys=ON")
        if err != nil </span><span class="cov0" title="0">{
                t.Fatalf("failed to open test database: %v", err)
        }</span>

        // Run schema
        <span class="cov0" title="0">if err := runTestMigrations(db); err != nil </span><span class="cov0" title="0">{
                db.Close()
                t.Fatalf("failed to run migrations: %v", err)
        }</span>

        <span class="cov0" title="0">t.Cleanup(func() </span><span class="cov0" title="0">{
                db.Close()
        }</span>)

        <span class="cov0" title="0">return db</span>
}

// runTestMigrations applies the database schema for testing
func runTestMigrations(db *sql.DB) error <span class="cov0" title="0">{
        schema := `
                -- Snippets table
                CREATE TABLE IF NOT EXISTS snippets (
                        id TEXT PRIMARY KEY DEFAULT (lower(hex(randomblob(8)))),
                        title TEXT NOT NULL,
                        description TEXT DEFAULT '',
                        content TEXT NOT NULL DEFAULT '',
                        language TEXT DEFAULT 'plaintext',
                        is_favorite INTEGER DEFAULT 0,
                        is_public INTEGER DEFAULT 0,
                        view_count INTEGER DEFAULT 0,
                        s3_key TEXT DEFAULT NULL,
                        checksum TEXT DEFAULT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );

                -- Tags table
                CREATE TABLE IF NOT EXISTS tags (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT UNIQUE NOT NULL,
                        color TEXT DEFAULT '#6366f1',
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );

                -- Snippet-Tag junction table
                CREATE TABLE IF NOT EXISTS snippet_tags (
                        snippet_id TEXT NOT NULL,
                        tag_id INTEGER NOT NULL,
                        PRIMARY KEY (snippet_id, tag_id),
                        FOREIGN KEY (snippet_id) REFERENCES snippets(id) ON DELETE CASCADE,
                        FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE
                );

                -- Folders table
                CREATE TABLE IF NOT EXISTS folders (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        parent_id INTEGER DEFAULT NULL,
                        icon TEXT DEFAULT 'folder',
                        sort_order INTEGER DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (parent_id) REFERENCES folders(id) ON DELETE CASCADE
                );

                -- Snippet-Folder relationship
                CREATE TABLE IF NOT EXISTS snippet_folders (
                        snippet_id TEXT NOT NULL,
                        folder_id INTEGER NOT NULL,
                        PRIMARY KEY (snippet_id, folder_id),
                        FOREIGN KEY (snippet_id) REFERENCES snippets(id) ON DELETE CASCADE,
                        FOREIGN KEY (folder_id) REFERENCES folders(id) ON DELETE CASCADE
                );

                -- API tokens
                CREATE TABLE IF NOT EXISTS api_tokens (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        name TEXT NOT NULL,
                        token_hash TEXT UNIQUE NOT NULL,
                        permissions TEXT DEFAULT 'read',
                        last_used_at DATETIME DEFAULT NULL,
                        expires_at DATETIME DEFAULT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );

                -- Sessions table
                CREATE TABLE IF NOT EXISTS sessions (
                        id TEXT PRIMARY KEY,
                        token_hash TEXT UNIQUE NOT NULL,
                        expires_at DATETIME NOT NULL,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP
                );

                -- Snippet files (multi-file support)
                CREATE TABLE IF NOT EXISTS snippet_files (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        snippet_id TEXT NOT NULL,
                        filename TEXT NOT NULL,
                        content TEXT DEFAULT '',
                        language TEXT DEFAULT 'plaintext',
                        sort_order INTEGER DEFAULT 0,
                        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                        FOREIGN KEY (snippet_id) REFERENCES snippets(id) ON DELETE CASCADE
                );

                -- Indexes
                CREATE INDEX IF NOT EXISTS idx_snippets_language ON snippets(language);
                CREATE INDEX IF NOT EXISTS idx_snippets_favorite ON snippets(is_favorite);
                CREATE INDEX IF NOT EXISTS idx_snippets_public ON snippets(is_public);
                CREATE INDEX IF NOT EXISTS idx_snippets_created ON snippets(created_at DESC);
                CREATE INDEX IF NOT EXISTS idx_snippets_updated ON snippets(updated_at DESC);
                CREATE INDEX IF NOT EXISTS idx_tags_name ON tags(name);
                CREATE INDEX IF NOT EXISTS idx_folders_parent ON folders(parent_id);
                CREATE INDEX IF NOT EXISTS idx_sessions_expires ON sessions(expires_at);
                CREATE INDEX IF NOT EXISTS idx_snippet_files_snippet ON snippet_files(snippet_id);

                -- Full-text search
                CREATE VIRTUAL TABLE IF NOT EXISTS snippets_fts USING fts5(
                        snippet_id,
                        title,
                        description,
                        content,
                        content='snippets',
                        content_rowid='rowid'
                );

                -- FTS triggers
                CREATE TRIGGER IF NOT EXISTS snippets_ai AFTER INSERT ON snippets BEGIN
                        INSERT INTO snippets_fts(rowid, snippet_id, title, description, content)
                        VALUES (NEW.rowid, NEW.id, NEW.title, NEW.description, NEW.content);
                END;

                CREATE TRIGGER IF NOT EXISTS snippets_ad AFTER DELETE ON snippets BEGIN
                        INSERT INTO snippets_fts(snippets_fts, rowid, snippet_id, title, description, content)
                        VALUES('delete', OLD.rowid, OLD.id, OLD.title, OLD.description, OLD.content);
                END;

                CREATE TRIGGER IF NOT EXISTS snippets_au AFTER UPDATE ON snippets BEGIN
                        INSERT INTO snippets_fts(snippets_fts, rowid, snippet_id, title, description, content)
                        VALUES('delete', OLD.rowid, OLD.id, OLD.title, OLD.description, OLD.content);
                        INSERT INTO snippets_fts(rowid, snippet_id, title, description, content)
                        VALUES (NEW.rowid, NEW.id, NEW.title, NEW.description, NEW.content);
                END;
        `

        _, err := db.Exec(schema)
        return err
}</span>

// TestLogger returns a no-op logger for testing
func TestLogger() *slog.Logger <span class="cov0" title="0">{
        return slog.New(slog.NewTextHandler(os.Stdout, &amp;slog.HandlerOptions{Level: slog.LevelError}))
}</span>

// TestContext returns a context for testing
func TestContext() context.Context <span class="cov0" title="0">{
        return context.Background()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">package validation

import (
        "regexp"
        "strings"
        "unicode/utf8"

        "github.com/MohamedElashri/snipo/internal/models"
)

// ValidationError represents a field validation error
type ValidationError struct {
        Field   string `json:"field"`
        Message string `json:"message"`
}

// ValidationErrors is a collection of validation errors
type ValidationErrors []ValidationError

// Error implements the error interface
func (ve ValidationErrors) Error() string <span class="cov2" title="2">{
        if len(ve) == 0 </span><span class="cov1" title="1">{
                return ""
        }</span>
        <span class="cov1" title="1">var msgs []string
        for _, e := range ve </span><span class="cov2" title="2">{
                msgs = append(msgs, e.Field+": "+e.Message)
        }</span>
        <span class="cov1" title="1">return strings.Join(msgs, "; ")</span>
}

// HasErrors returns true if there are validation errors
func (ve ValidationErrors) HasErrors() bool <span class="cov9" title="30">{
        return len(ve) &gt; 0
}</span>

// Allowed languages (subset of Prism.js supported languages)
var allowedLanguages = map[string]bool{
        "plaintext": true, "javascript": true, "typescript": true, "python": true,
        "go": true, "rust": true, "java": true, "c": true, "cpp": true, "csharp": true,
        "php": true, "ruby": true, "swift": true, "kotlin": true, "scala": true,
        "html": true, "css": true, "scss": true, "json": true, "yaml": true, "xml": true,
        "markdown": true, "sql": true, "bash": true, "shell": true, "powershell": true,
        "dockerfile": true, "nginx": true, "toml": true, "ini": true, "makefile": true,
        "lua": true, "perl": true, "r": true, "haskell": true, "elixir": true,
        "clojure": true, "graphql": true, "protobuf": true, "terraform": true,
}

// tagRegex validates tag names
var tagRegex = regexp.MustCompile(`^[a-zA-Z0-9_-]+$`)

// ValidateSnippetInput validates snippet input
func ValidateSnippetInput(input *models.SnippetInput) ValidationErrors <span class="cov9" title="32">{
        var errs ValidationErrors

        // Title validation
        input.Title = strings.TrimSpace(input.Title)
        if input.Title == "" </span><span class="cov1" title="1">{
                errs = append(errs, ValidationError{Field: "title", Message: "Title is required"})
        }</span> else<span class="cov9" title="31"> if utf8.RuneCountInString(input.Title) &gt; 200 </span><span class="cov1" title="1">{
                errs = append(errs, ValidationError{Field: "title", Message: "Title must be less than 200 characters"})
        }</span>

        // Content validation (skip if multi-file snippet with files)
        <span class="cov9" title="32">hasFiles := len(input.Files) &gt; 0
        if !hasFiles &amp;&amp; strings.TrimSpace(input.Content) == "" </span><span class="cov1" title="1">{
                errs = append(errs, ValidationError{Field: "content", Message: "Content is required"})
        }</span> else<span class="cov9" title="31"> if len(input.Content) &gt; 1024*1024 </span><span class="cov0" title="0">{ // 1MB limit
                errs = append(errs, ValidationError{Field: "content", Message: "Content must be less than 1MB"})
        }</span>

        // Validate files if present
        <span class="cov9" title="32">for i, file := range input.Files </span><span class="cov4" title="4">{
                if strings.TrimSpace(file.Filename) == "" </span><span class="cov1" title="1">{
                        errs = append(errs, ValidationError{Field: "files", Message: "Filename is required for all files"})
                }</span>
                <span class="cov4" title="4">if len(file.Content) &gt; 1024*1024 </span><span class="cov0" title="0">{ // 1MB limit per file
                        errs = append(errs, ValidationError{Field: "files", Message: "File content must be less than 1MB each"})
                }</span>
                // Validate file language
                <span class="cov4" title="4">lang := strings.ToLower(strings.TrimSpace(file.Language))
                if lang == "" </span><span class="cov1" title="1">{
                        input.Files[i].Language = "plaintext"
                }</span> else<span class="cov3" title="3"> if !allowedLanguages[lang] </span><span class="cov1" title="1">{
                        input.Files[i].Language = "plaintext" // Default to plaintext if invalid
                }</span>
        }

        // Language validation
        <span class="cov9" title="32">input.Language = strings.ToLower(strings.TrimSpace(input.Language))
        if input.Language == "" </span><span class="cov1" title="1">{
                input.Language = "plaintext"
        }</span> else<span class="cov9" title="31"> if !allowedLanguages[input.Language] </span><span class="cov1" title="1">{
                errs = append(errs, ValidationError{Field: "language", Message: "Invalid language"})
        }</span>

        // Description length
        <span class="cov9" title="32">input.Description = strings.TrimSpace(input.Description)
        if utf8.RuneCountInString(input.Description) &gt; 500 </span><span class="cov1" title="1">{
                errs = append(errs, ValidationError{Field: "description", Message: "Description must be less than 500 characters"})
        }</span>

        // Tag validation
        <span class="cov9" title="32">for i, tag := range input.Tags </span><span class="cov6" title="8">{
                tag = strings.TrimSpace(tag)
                input.Tags[i] = tag
                if tag == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov6" title="8">if len(tag) &gt; 50 </span><span class="cov1" title="1">{
                        errs = append(errs, ValidationError{Field: "tags", Message: "Tag name must be less than 50 characters"})
                }</span> else<span class="cov5" title="7"> if !tagRegex.MatchString(tag) </span><span class="cov1" title="1">{
                        errs = append(errs, ValidationError{Field: "tags", Message: "Tag can only contain letters, numbers, underscores, and hyphens"})
                }</span>
        }

        <span class="cov9" title="32">return errs</span>
}

// GetAllowedLanguages returns a list of allowed language identifiers
func GetAllowedLanguages() []string <span class="cov1" title="1">{
        languages := make([]string, 0, len(allowedLanguages))
        for lang := range allowedLanguages </span><span class="cov10" title="40">{
                languages = append(languages, lang)
        }</span>
        <span class="cov1" title="1">return languages</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">package web

import (
        "embed"
        "html/template"
        "io/fs"
        "net/http"
        "path/filepath"

        "github.com/MohamedElashri/snipo/internal/auth"
)

//go:embed templates/*.html
var templatesFS embed.FS

//go:embed static/css/*.css static/js/*.js static/vendor/css/*.css static/vendor/js/*.js static/vendor/fonts/*.woff2
var staticFS embed.FS

// Handler handles web page requests
type Handler struct {
        templates   *template.Template
        authService *auth.Service
}

// NewHandler creates a new web handler
func NewHandler(authService *auth.Service) (*Handler, error) <span class="cov0" title="0">{
        // Parse templates
        tmpl, err := template.ParseFS(templatesFS, "templates/*.html")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;Handler{
                templates:   tmpl,
                authService: authService,
        }, nil</span>
}

// StaticHandler returns a handler for static files
func StaticHandler() http.Handler <span class="cov0" title="0">{
        staticContent, _ := fs.Sub(staticFS, "static")
        return http.StripPrefix("/static/", http.FileServer(http.FS(staticContent)))
}</span>

// PageData holds data passed to templates
type PageData struct {
        Title string
}

// Index serves the main application page
func (h *Handler) Index(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // Check authentication
        token := auth.GetSessionFromRequest(r)
        if token == "" || !h.authService.ValidateSession(token) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/login", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">data := PageData{Title: "Snippets"}
        h.render(w, "layout.html", "index.html", data)</span>
}

// Login serves the login page
func (h *Handler) Login(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        // If already authenticated, redirect to home
        token := auth.GetSessionFromRequest(r)
        if token != "" &amp;&amp; h.authService.ValidateSession(token) </span><span class="cov0" title="0">{
                http.Redirect(w, r, "/", http.StatusSeeOther)
                return
        }</span>

        <span class="cov0" title="0">data := PageData{Title: "Login"}
        h.render(w, "layout.html", "login.html", data)</span>
}

// PublicSnippet serves the public snippet view page (no auth required)
func (h *Handler) PublicSnippet(w http.ResponseWriter, r *http.Request) <span class="cov0" title="0">{
        data := PageData{Title: "Shared Snippet"}
        h.render(w, "layout.html", "public.html", data)
}</span>

// render renders a template with layout
func (h *Handler) render(w http.ResponseWriter, layout, content string, data interface{}) <span class="cov0" title="0">{
        // Create a new template that combines layout and content
        tmpl, err := template.ParseFS(templatesFS,
                filepath.Join("templates", layout),
                filepath.Join("templates", content),
        )
        if err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Template parse error: "+err.Error(), http.StatusInternalServerError)
                return
        }</span>

        <span class="cov0" title="0">w.Header().Set("Content-Type", "text/html; charset=utf-8")
        if err := tmpl.ExecuteTemplate(w, layout, data); err != nil </span><span class="cov0" title="0">{
                http.Error(w, "Template execute error: "+err.Error(), http.StatusInternalServerError)
        }</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
